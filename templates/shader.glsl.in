/*
 * RetroFX shader template.
 * Generated by scripts/retrofx.
 */

#define MODE_PASSTHROUGH @MODE_PASSTHROUGH@
#define MODE_MONO @MODE_MONO@
#define MODE_PALETTE @MODE_PALETTE@

#define MONO_BANDS @MONO_BANDS@
#define PHOSPHOR_R @PHOSPHOR_R@
#define PHOSPHOR_G @PHOSPHOR_G@
#define PHOSPHOR_B @PHOSPHOR_B@
#define HOTCORE @HOTCORE@

#define ENABLE_DITHER @ENABLE_DITHER@
#define ENABLE_SCANLINES @ENABLE_SCANLINES@
#define ENABLE_FLICKER @ENABLE_FLICKER@
#define ENABLE_VIGNETTE @ENABLE_VIGNETTE@

#define PALETTE_KIND_VGA16 @PALETTE_KIND_VGA16@
#define PALETTE_KIND_CUBE256 @PALETTE_KIND_CUBE256@
#define PALETTE_KIND_CUSTOM @PALETTE_KIND_CUSTOM@
#define PALETTE_SIZE @PALETTE_SIZE@
#define CUSTOM_PALETTE_SIZE @CUSTOM_PALETTE_SIZE@

uniform sampler2D tex;
uniform float opacity;
uniform float time;
varying vec2 texcoord;

const vec3 VGA16[16] = vec3[](
    vec3(0.000000, 0.000000, 0.000000),
    vec3(0.666667, 0.000000, 0.000000),
    vec3(0.000000, 0.666667, 0.000000),
    vec3(0.666667, 0.333333, 0.000000),
    vec3(0.000000, 0.000000, 0.666667),
    vec3(0.666667, 0.000000, 0.666667),
    vec3(0.000000, 0.666667, 0.666667),
    vec3(0.666667, 0.666667, 0.666667),
    vec3(0.333333, 0.333333, 0.333333),
    vec3(1.000000, 0.333333, 0.333333),
    vec3(0.333333, 1.000000, 0.333333),
    vec3(1.000000, 1.000000, 0.333333),
    vec3(0.333333, 0.333333, 1.000000),
    vec3(1.000000, 0.333333, 1.000000),
    vec3(0.333333, 1.000000, 1.000000),
    vec3(1.000000, 1.000000, 1.000000)
);

@CUSTOM_PALETTE_BLOCK@

float clamp01(float v) {
    return clamp(v, 0.0, 1.0);
}

vec3 srgb_to_linear(vec3 c) {
    return pow(max(c, vec3(0.0)), vec3(2.2));
}

vec3 linear_to_srgb(vec3 c) {
    return pow(max(c, vec3(0.0)), vec3(1.0 / 2.2));
}

float luminance(vec3 c) {
    return dot(c, vec3(0.2126, 0.7152, 0.0722));
}

vec3 tone_transform(vec3 c) {
    /* Keep transform deterministic and subtle for performance and readability. */
    c = pow(c, vec3(1.0 / 1.03));
    c = (c - 0.5) * 1.06 + 0.5;
    return clamp(c, 0.0, 1.0);
}

float bayer4(vec2 p) {
    int x = int(mod(p.x, 4.0));
    int y = int(mod(p.y, 4.0));
    int i = x + y * 4;

    if (i == 0) return 0.0;
    if (i == 1) return 8.0;
    if (i == 2) return 2.0;
    if (i == 3) return 10.0;
    if (i == 4) return 12.0;
    if (i == 5) return 4.0;
    if (i == 6) return 14.0;
    if (i == 7) return 6.0;
    if (i == 8) return 3.0;
    if (i == 9) return 11.0;
    if (i == 10) return 1.0;
    if (i == 11) return 9.0;
    if (i == 12) return 15.0;
    if (i == 13) return 7.0;
    if (i == 14) return 13.0;
    return 5.0;
}

float quantize_1d(float x, int bands) {
    float b = float(max(bands, 2));
    float q = floor(clamp01(x) * (b - 1.0) + 0.5);
    return q / (b - 1.0);
}

vec3 quantize_vga16(vec3 c, int limit) {
    vec3 best = srgb_to_linear(VGA16[0]);
    float best_d = 1e9;
    int max_colors = clamp(limit, 2, 16);
    int i;

    for (i = 0; i < 16; i++) {
        if (i >= max_colors) {
            break;
        }
        vec3 p = srgb_to_linear(VGA16[i]);
        float d = dot(c - p, c - p);
        if (d < best_d) {
            best_d = d;
            best = p;
        }
    }

    return best;
}

vec3 quantize_cube256(vec3 c, int size) {
    vec3 cube;
    vec3 gray;

    if (size >= 256) {
        cube = floor(c * 5.0 + 0.5) / 5.0;
        float l = luminance(c);
        float g = floor(l * 23.0 + 0.5) / 23.0;
        gray = vec3(g);
    } else {
        int levels = int(floor(pow(float(max(size, 2)), 1.0 / 3.0) + 0.5));
        levels = clamp(levels, 2, 6);
        float lf = float(levels - 1);
        cube = floor(c * lf + 0.5) / lf;

        int gray_levels = int(floor(float(max(size, 2)) / float(levels * levels)));
        gray_levels = clamp(gray_levels, 2, 24);
        float gf = float(gray_levels - 1);
        float g = floor(luminance(c) * gf + 0.5) / gf;
        gray = vec3(g);
    }

    return dot(c - gray, c - gray) < dot(c - cube, c - cube) ? gray : cube;
}

vec3 quantize_custom(vec3 c) {
    vec3 best = CUSTOM_PALETTE[0];
    float best_d = dot(c - best, c - best);
    int i;

    for (i = 1; i < CUSTOM_PALETTE_SIZE; i++) {
        vec3 p = CUSTOM_PALETTE[i];
        float d = dot(c - p, c - p);
        if (d < best_d) {
            best_d = d;
            best = p;
        }
    }

    return best;
}

vec3 quantize_palette(vec3 c) {
#if PALETTE_KIND_VGA16 == 1
    return quantize_vga16(c, PALETTE_SIZE);
#elif PALETTE_KIND_CUBE256 == 1
    return quantize_cube256(c, PALETTE_SIZE);
#elif PALETTE_KIND_CUSTOM == 1
    return quantize_custom(c);
#else
    return c;
#endif
}

void main() {
    vec4 src = texture2D(tex, texcoord);
    vec3 lin = srgb_to_linear(src.rgb);
    vec3 outc;

    lin = tone_transform(lin);

#if MODE_PASSTHROUGH == 1
    outc = lin;
#else
    if (ENABLE_DITHER == 1) {
        float d = (bayer4(gl_FragCoord.xy) + 0.5) / 16.0;
        lin = clamp(lin + vec3((d - 0.5) * 0.04), 0.0, 1.0);
    }

#if MODE_MONO == 1
    {
        float y = luminance(lin);
        float q = quantize_1d(y, MONO_BANDS);
        vec3 phosphor = vec3(PHOSPHOR_R, PHOSPHOR_G, PHOSPHOR_B);
        outc = phosphor * q;
#if HOTCORE == 1
        {
            float core = smoothstep(0.72, 1.0, q);
            outc = mix(outc, vec3(1.0), core * 0.65);
        }
#endif
    }
#elif MODE_PALETTE == 1
    outc = quantize_palette(lin);
#else
    outc = lin;
#endif
#endif

#if ENABLE_SCANLINES == 1
    {
        float s = 0.985 + 0.015 * sin((gl_FragCoord.y + 0.5) * 3.14159265);
        outc *= s;
    }
#endif

#if ENABLE_FLICKER == 1
    {
        float t = 1.0 + 0.015 * sin(time * 1.3);
        outc *= t;
    }
#endif

#if ENABLE_VIGNETTE == 1
    {
        vec2 p = texcoord - vec2(0.5, 0.5);
        float v = 1.0 - dot(p, p) * 0.55;
        outc *= clamp(v, 0.82, 1.0);
    }
#endif

    outc = clamp(outc, 0.0, 1.0);
    gl_FragColor = vec4(linear_to_srgb(outc), src.a * opacity);
}
