/*
 * RetroFX shader template.
 * Generated by scripts/retrofx.
 *
 * Canonical pipeline order:
 *   1) Linearize
 *   2) Transform / tint preparation
 *   3) Quantize
 *   4) Ordered dither (post-quantization modulation)
 *   5) Scanlines
 *   6) Flicker
 *   7) Vignette
 *   8) Encode (linear -> sRGB)
 *
 * Complexity notes:
 *   - Monochrome path: O(1)
 *   - VGA16 path: O(16)
 *   - Structured cube paths (32/64/128/256): O(1), arithmetic quantization
 *   - Custom palette path: O(N), N <= 32
 */

#define MODE_PASSTHROUGH @MODE_PASSTHROUGH@
#define MODE_MONO @MODE_MONO@
#define MODE_PALETTE @MODE_PALETTE@

#define MONO_BANDS @MONO_BANDS@
#define MONO_LEVELS @MONO_LEVELS@
#define MONO_INV_LEVELS @MONO_INV_LEVELS@
#define PHOSPHOR_R @PHOSPHOR_R@
#define PHOSPHOR_G @PHOSPHOR_G@
#define PHOSPHOR_B @PHOSPHOR_B@
#define HOTCORE @HOTCORE@

#define ENABLE_DITHER @ENABLE_DITHER@
#define ENABLE_SCANLINES @ENABLE_SCANLINES@
#define ENABLE_FLICKER @ENABLE_FLICKER@
#define ENABLE_VIGNETTE @ENABLE_VIGNETTE@
#define SCANLINE_BASE @SCANLINE_BASE@
#define SCANLINE_AMP @SCANLINE_AMP@

#define PALETTE_KIND_VGA16 @PALETTE_KIND_VGA16@
#define PALETTE_KIND_MONO2 @PALETTE_KIND_MONO2@
#define PALETTE_KIND_MONO4 @PALETTE_KIND_MONO4@
#define PALETTE_KIND_MONO8 @PALETTE_KIND_MONO8@
#define PALETTE_KIND_MONO16 @PALETTE_KIND_MONO16@
#define PALETTE_KIND_CUBE32 @PALETTE_KIND_CUBE32@
#define PALETTE_KIND_CUBE64 @PALETTE_KIND_CUBE64@
#define PALETTE_KIND_CUBE128 @PALETTE_KIND_CUBE128@
#define PALETTE_KIND_CUBE256 @PALETTE_KIND_CUBE256@
#define PALETTE_KIND_CUSTOM @PALETTE_KIND_CUSTOM@
#define PALETTE_SIZE @PALETTE_SIZE@
#define CUSTOM_PALETTE_SIZE @CUSTOM_PALETTE_SIZE@
#define BG_TINT_LINEAR_R @BG_TINT_LINEAR_R@
#define BG_TINT_LINEAR_G @BG_TINT_LINEAR_G@
#define BG_TINT_LINEAR_B @BG_TINT_LINEAR_B@

/* Cube256 arithmetic constants are compile-time to avoid per-pixel recomputation. */
const float CUBE256_CUBE_SCALE = 5.0;
const float CUBE256_GRAY_SCALE = 23.0;
const float CUBE256_INV_CUBE_SCALE = 0.2;       /* 1 / 5 */
const float CUBE256_INV_GRAY_SCALE = 0.043478261; /* 1 / 23 */

uniform sampler2D tex;
uniform float opacity;
uniform float time;
varying vec2 texcoord;

/* VGA16 palette represented directly in linear space for lower inner-loop cost. */
const vec3 VGA16_LINEAR[16] = vec3[](
    vec3(0.000000, 0.000000, 0.000000),
    vec3(0.409826, 0.000000, 0.000000),
    vec3(0.000000, 0.409826, 0.000000),
    vec3(0.409826, 0.089193, 0.000000),
    vec3(0.000000, 0.000000, 0.409826),
    vec3(0.409826, 0.000000, 0.409826),
    vec3(0.000000, 0.409826, 0.409826),
    vec3(0.409826, 0.409826, 0.409826),
    vec3(0.089193, 0.089193, 0.089193),
    vec3(1.000000, 0.089193, 0.089193),
    vec3(0.089193, 1.000000, 0.089193),
    vec3(1.000000, 1.000000, 0.089193),
    vec3(0.089193, 0.089193, 1.000000),
    vec3(1.000000, 0.089193, 1.000000),
    vec3(0.089193, 1.000000, 1.000000),
    vec3(1.000000, 1.000000, 1.000000)
);

@CUSTOM_PALETTE_BLOCK@

float clamp01(float v) {
    return clamp(v, 0.0, 1.0);
}

int clamp_int(int v, int lo, int hi) {
    if (v < lo) {
        return lo;
    }
    if (v > hi) {
        return hi;
    }
    return v;
}

vec3 srgb_to_linear(vec3 c) {
    return pow(max(c, vec3(0.0)), vec3(2.2));
}

vec3 linear_to_srgb(vec3 c) {
    return pow(max(c, vec3(0.0)), vec3(1.0 / 2.2));
}

float luminance(vec3 c) {
    return dot(c, vec3(0.2126, 0.7152, 0.0722));
}

vec3 tone_transform(vec3 c) {
    c = pow(clamp(c, 0.0, 1.0), vec3(1.0 / 1.03));
    c = (c - 0.5) * 1.06 + 0.5;
    return clamp(c, 0.0, 1.0);
}

/* Ordered Bayer 4x4: values 0..15, constant-table lookup, no out-of-range indexing. */
float bayer4(vec2 p) {
    const float BAYER4[16] = float[](
        0.0, 8.0, 2.0, 10.0,
        12.0, 4.0, 14.0, 6.0,
        3.0, 11.0, 1.0, 9.0,
        15.0, 7.0, 13.0, 5.0
    );
    int x = int(mod(p.x, 4.0));
    int y = int(mod(p.y, 4.0));
    int i = x + y * 4;
    return BAYER4[i];
}

/* q = round(L * (N - 1)) / (N - 1), with N guarded to [2, 256]. */
float quantize_1d(float x, int bands) {
    int safe_bands = bands;
    if (safe_bands < 2) {
        safe_bands = 2;
    }
    if (safe_bands > 256) {
        safe_bands = 256;
    }

    float levels = float(safe_bands - 1);
    float q = floor(clamp01(x) * levels + 0.5);
    return q / levels;
}

/* O(16) search in linear space. */
vec3 quantize_vga16(vec3 c, int limit) {
    vec3 best = VGA16_LINEAR[0];
    float best_d = 1e9;
    int max_colors = limit;
    int i;

    if (max_colors < 2) {
        max_colors = 2;
    }
    if (max_colors > 16) {
        max_colors = 16;
    }

    for (i = 0; i < 16; i++) {
        if (i >= max_colors) {
            break;
        }
        vec3 p = VGA16_LINEAR[i];
        float d = dot(c - p, c - p);
        if (d < best_d) {
            best_d = d;
            best = p;
        }
    }

    return best;
}

vec3 quantize_cube_levels(vec3 c, int rl, int gl, int bl) {
    vec3 cc = clamp(c, 0.0, 1.0);
    int ri;
    int gi;
    int bi;
    float rf;
    float gf;
    float bf;

    rl = clamp_int(rl, 2, 8);
    gl = clamp_int(gl, 2, 8);
    bl = clamp_int(bl, 2, 8);

    rf = float(rl - 1);
    gf = float(gl - 1);
    bf = float(bl - 1);

    ri = int(floor(cc.r * rf + 0.5));
    gi = int(floor(cc.g * gf + 0.5));
    bi = int(floor(cc.b * bf + 0.5));

    ri = clamp_int(ri, 0, rl - 1);
    gi = clamp_int(gi, 0, gl - 1);
    bi = clamp_int(bi, 0, bl - 1);

    return vec3(float(ri) / rf, float(gi) / gf, float(bi) / bf);
}

/* 32-color deterministic scheme: 3x3x3 cube + 5 grayscale levels. */
vec3 quantize_cube32(vec3 c) {
    vec3 cc = clamp(c, 0.0, 1.0);
    vec3 cube = quantize_cube_levels(cc, 3, 3, 3);
    int gi = int(floor(luminance(cc) * 4.0 + 0.5));
    vec3 gray;
    gi = clamp_int(gi, 0, 4);
    gray = vec3(float(gi) / 4.0);
    return (dot(cc - gray, cc - gray) < dot(cc - cube, cc - cube)) ? gray : cube;
}

/* 64-color arithmetic cube: 4x4x4. */
vec3 quantize_cube64(vec3 c) {
    return quantize_cube_levels(c, 4, 4, 4);
}

/* 128-color arithmetic cube: 4x4x8. */
vec3 quantize_cube128(vec3 c) {
    return quantize_cube_levels(c, 4, 4, 8);
}

/* 256-color arithmetic scheme: 6x6x6 cube + 24-step grayscale ramp selection. */
vec3 quantize_cube256(vec3 c) {
    vec3 cc = clamp(c, 0.0, 1.0);
    vec3 cube;
    vec3 gray;
    int ri = int(floor(cc.r * CUBE256_CUBE_SCALE + 0.5));
    int gi = int(floor(cc.g * CUBE256_CUBE_SCALE + 0.5));
    int bi = int(floor(cc.b * CUBE256_CUBE_SCALE + 0.5));
    int gri = int(floor(luminance(cc) * CUBE256_GRAY_SCALE + 0.5));

    ri = clamp_int(ri, 0, 5);
    gi = clamp_int(gi, 0, 5);
    bi = clamp_int(bi, 0, 5);
    gri = clamp_int(gri, 0, 23);

    cube = vec3(float(ri), float(gi), float(bi)) * CUBE256_INV_CUBE_SCALE;
    gray = vec3(float(gri) * CUBE256_INV_GRAY_SCALE);
    return (dot(cc - gray, cc - gray) < dot(cc - cube, cc - cube)) ? gray : cube;
}

vec3 quantize_custom(vec3 c) {
    vec3 best = CUSTOM_PALETTE[0];
    float best_d = dot(c - best, c - best);
    int i;

    for (i = 1; i < CUSTOM_PALETTE_SIZE; i++) {
        vec3 p = CUSTOM_PALETTE[i];
        float d = dot(c - p, c - p);
        if (d < best_d) {
            best_d = d;
            best = p;
        }
    }

    return best;
}

vec3 quantize_palette(vec3 c) {
#if PALETTE_KIND_VGA16 == 1
    return quantize_vga16(c, PALETTE_SIZE);
#elif PALETTE_KIND_MONO2 == 1
    return vec3(quantize_1d(luminance(c), 2));
#elif PALETTE_KIND_MONO4 == 1
    return vec3(quantize_1d(luminance(c), 4));
#elif PALETTE_KIND_MONO8 == 1
    return vec3(quantize_1d(luminance(c), 8));
#elif PALETTE_KIND_MONO16 == 1
    return vec3(quantize_1d(luminance(c), 16));
#elif PALETTE_KIND_CUBE32 == 1
    return quantize_cube32(c);
#elif PALETTE_KIND_CUBE64 == 1
    return quantize_cube64(c);
#elif PALETTE_KIND_CUBE128 == 1
    return quantize_cube128(c);
#elif PALETTE_KIND_CUBE256 == 1
    return quantize_cube256(c);
#elif PALETTE_KIND_CUSTOM == 1
    return quantize_custom(c);
#else
    return c;
#endif
}

void main() {
    vec4 src = texture2D(tex, texcoord);
    vec3 lin;
    vec3 outc;

    /* PIPELINE_STEP_1_LINEARIZE */
    lin = srgb_to_linear(src.rgb);

    /* PIPELINE_STEP_2_TRANSFORM */
    lin = tone_transform(lin);

    outc = lin;

#if MODE_PASSTHROUGH == 1
    /* passthrough: quantization and dithering are intentionally skipped */
#else
    /* PIPELINE_STEP_3_QUANTIZE */
#if MODE_MONO == 1
    {
        float y = luminance(lin);
        /* Uses precomputed inverse to avoid division per fragment. */
        float q = floor(clamp01(y) * float(MONO_LEVELS) + 0.5) * MONO_INV_LEVELS;
        vec3 phosphor = vec3(PHOSPHOR_R, PHOSPHOR_G, PHOSPHOR_B);
        vec3 bg_tint = vec3(BG_TINT_LINEAR_R, BG_TINT_LINEAR_G, BG_TINT_LINEAR_B);
        outc = mix(bg_tint, phosphor * q, q);
#if HOTCORE == 1
        {
            float core = smoothstep(0.72, 1.0, q);
            outc = mix(outc, vec3(1.0), core * 0.65);
        }
#endif
    }
#elif MODE_PALETTE == 1
    outc = quantize_palette(lin);
#else
    outc = lin;
#endif

    /* PIPELINE_STEP_4_DITHER */
#if ENABLE_DITHER == 1
#if MODE_MONO == 1 || MODE_PALETTE == 1
    {
        float d = (bayer4(gl_FragCoord.xy) + 0.5) / 16.0;
        outc = clamp(outc + vec3((d - 0.5) * 0.03), 0.0, 1.0);
    }
#endif
#endif
#endif

    /* PIPELINE_STEP_5_SCANLINES */
#if ENABLE_SCANLINES == 1
    {
        float s = SCANLINE_BASE + SCANLINE_AMP * sin((gl_FragCoord.y + 0.5) * 3.14159265);
        outc *= s;
    }
#endif

    /* PIPELINE_STEP_6_FLICKER */
#if ENABLE_FLICKER == 1
    {
        float t = 1.0 + 0.015 * sin(time * 1.3);
        outc *= t;
    }
#endif

    /* PIPELINE_STEP_7_VIGNETTE */
#if ENABLE_VIGNETTE == 1
    {
        vec2 p = texcoord - vec2(0.5, 0.5);
        float v = 1.0 - dot(p, p) * 0.55;
        outc *= clamp(v, 0.82, 1.0);
    }
#endif

    outc = clamp(outc, 0.0, 1.0);

    /* PIPELINE_STEP_8_ENCODE */
    gl_FragColor = vec4(linear_to_srgb(outc), src.a * opacity);
}
