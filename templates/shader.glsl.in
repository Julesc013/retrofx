/*
 * RetroFX shader template.
 * Generated by scripts/retrofx.
 *
 * Canonical pipeline order:
 *   1) Linearize
 *   2) Transform / tint preparation
 *   3) Quantize
 *   4) Ordered dither (post-quantization modulation)
 *   5) Scanlines
 *   6) Flicker
 *   7) Vignette
 *   8) Encode (linear -> sRGB)
 *
 * Complexity notes:
 *   - Monochrome path: O(1)
 *   - VGA16 path: O(16)
 *   - cube256 path: O(1), arithmetic quantization (no palette search loop)
 */

#define MODE_PASSTHROUGH @MODE_PASSTHROUGH@
#define MODE_MONO @MODE_MONO@
#define MODE_PALETTE @MODE_PALETTE@

#define MONO_BANDS @MONO_BANDS@
#define PHOSPHOR_R @PHOSPHOR_R@
#define PHOSPHOR_G @PHOSPHOR_G@
#define PHOSPHOR_B @PHOSPHOR_B@
#define HOTCORE @HOTCORE@

#define ENABLE_DITHER @ENABLE_DITHER@
#define ENABLE_SCANLINES @ENABLE_SCANLINES@
#define ENABLE_FLICKER @ENABLE_FLICKER@
#define ENABLE_VIGNETTE @ENABLE_VIGNETTE@

#define PALETTE_KIND_VGA16 @PALETTE_KIND_VGA16@
#define PALETTE_KIND_CUBE256 @PALETTE_KIND_CUBE256@
#define PALETTE_KIND_CUSTOM @PALETTE_KIND_CUSTOM@
#define PALETTE_SIZE @PALETTE_SIZE@
#define CUSTOM_PALETTE_SIZE @CUSTOM_PALETTE_SIZE@

uniform sampler2D tex;
uniform float opacity;
uniform float time;
varying vec2 texcoord;

/* VGA16 palette represented directly in linear space for lower inner-loop cost. */
const vec3 VGA16_LINEAR[16] = vec3[](
    vec3(0.000000, 0.000000, 0.000000),
    vec3(0.409826, 0.000000, 0.000000),
    vec3(0.000000, 0.409826, 0.000000),
    vec3(0.409826, 0.089193, 0.000000),
    vec3(0.000000, 0.000000, 0.409826),
    vec3(0.409826, 0.000000, 0.409826),
    vec3(0.000000, 0.409826, 0.409826),
    vec3(0.409826, 0.409826, 0.409826),
    vec3(0.089193, 0.089193, 0.089193),
    vec3(1.000000, 0.089193, 0.089193),
    vec3(0.089193, 1.000000, 0.089193),
    vec3(1.000000, 1.000000, 0.089193),
    vec3(0.089193, 0.089193, 1.000000),
    vec3(1.000000, 0.089193, 1.000000),
    vec3(0.089193, 1.000000, 1.000000),
    vec3(1.000000, 1.000000, 1.000000)
);

@CUSTOM_PALETTE_BLOCK@

float clamp01(float v) {
    return clamp(v, 0.0, 1.0);
}

int clamp_int(int v, int lo, int hi) {
    if (v < lo) {
        return lo;
    }
    if (v > hi) {
        return hi;
    }
    return v;
}

vec3 srgb_to_linear(vec3 c) {
    return pow(max(c, vec3(0.0)), vec3(2.2));
}

vec3 linear_to_srgb(vec3 c) {
    return pow(max(c, vec3(0.0)), vec3(1.0 / 2.2));
}

float luminance(vec3 c) {
    return dot(c, vec3(0.2126, 0.7152, 0.0722));
}

vec3 tone_transform(vec3 c) {
    c = pow(clamp(c, 0.0, 1.0), vec3(1.0 / 1.03));
    c = (c - 0.5) * 1.06 + 0.5;
    return clamp(c, 0.0, 1.0);
}

/* Ordered Bayer 4x4: values 0..15, no out-of-range indexing. */
float bayer4(vec2 p) {
    int x = int(mod(p.x, 4.0));
    int y = int(mod(p.y, 4.0));
    int i = x + y * 4;

    if (i == 0) return 0.0;
    if (i == 1) return 8.0;
    if (i == 2) return 2.0;
    if (i == 3) return 10.0;
    if (i == 4) return 12.0;
    if (i == 5) return 4.0;
    if (i == 6) return 14.0;
    if (i == 7) return 6.0;
    if (i == 8) return 3.0;
    if (i == 9) return 11.0;
    if (i == 10) return 1.0;
    if (i == 11) return 9.0;
    if (i == 12) return 15.0;
    if (i == 13) return 7.0;
    if (i == 14) return 13.0;
    return 5.0;
}

/* q = round(L * (N - 1)) / (N - 1), with N guarded to [2, 256]. */
float quantize_1d(float x, int bands) {
    int safe_bands = bands;
    if (safe_bands < 2) {
        safe_bands = 2;
    }
    if (safe_bands > 256) {
        safe_bands = 256;
    }

    float levels = float(safe_bands - 1);
    float q = floor(clamp01(x) * levels + 0.5);
    return q / levels;
}

/* O(16) search in linear space. */
vec3 quantize_vga16(vec3 c, int limit) {
    vec3 best = VGA16_LINEAR[0];
    float best_d = 1e9;
    int max_colors = limit;
    int i;

    if (max_colors < 2) {
        max_colors = 2;
    }
    if (max_colors > 16) {
        max_colors = 16;
    }

    for (i = 0; i < 16; i++) {
        if (i >= max_colors) {
            break;
        }
        vec3 p = VGA16_LINEAR[i];
        float d = dot(c - p, c - p);
        if (d < best_d) {
            best_d = d;
            best = p;
        }
    }

    return best;
}

/* O(1) arithmetic quantization for cube + grayscale ramp. */
vec3 quantize_cube256(vec3 c, int size) {
    vec3 cc = clamp(c, 0.0, 1.0);
    vec3 cube;
    vec3 gray;

    if (size >= 256) {
        int ri = int(floor(cc.r * 5.0 + 0.5));
        int gi = int(floor(cc.g * 5.0 + 0.5));
        int bi = int(floor(cc.b * 5.0 + 0.5));
        int gri = int(floor(luminance(cc) * 23.0 + 0.5));

        ri = clamp_int(ri, 0, 5);
        gi = clamp_int(gi, 0, 5);
        bi = clamp_int(bi, 0, 5);
        gri = clamp_int(gri, 0, 23);

        cube = vec3(float(ri), float(gi), float(bi)) / 5.0;
        gray = vec3(float(gri) / 23.0);
    } else {
        int safe_size = size;
        int levels;
        int gray_levels;
        float lf;
        float gf;
        int ri;
        int gi;
        int bi;
        int gri;

        if (safe_size < 2) {
            safe_size = 2;
        }

        levels = int(floor(pow(float(safe_size), 1.0 / 3.0) + 0.5));
        levels = clamp_int(levels, 2, 6);
        lf = float(levels - 1);

        ri = int(floor(cc.r * lf + 0.5));
        gi = int(floor(cc.g * lf + 0.5));
        bi = int(floor(cc.b * lf + 0.5));
        ri = clamp_int(ri, 0, levels - 1);
        gi = clamp_int(gi, 0, levels - 1);
        bi = clamp_int(bi, 0, levels - 1);

        cube = vec3(float(ri), float(gi), float(bi)) / lf;

        gray_levels = int(floor(float(safe_size) / float(levels * levels)));
        gray_levels = clamp_int(gray_levels, 2, 24);
        gf = float(gray_levels - 1);
        gri = int(floor(luminance(cc) * gf + 0.5));
        gri = clamp_int(gri, 0, gray_levels - 1);
        gray = vec3(float(gri) / gf);
    }

    return (dot(cc - gray, cc - gray) < dot(cc - cube, cc - cube)) ? gray : cube;
}

vec3 quantize_custom(vec3 c) {
    vec3 best = CUSTOM_PALETTE[0];
    float best_d = dot(c - best, c - best);
    int i;

    for (i = 1; i < CUSTOM_PALETTE_SIZE; i++) {
        vec3 p = CUSTOM_PALETTE[i];
        float d = dot(c - p, c - p);
        if (d < best_d) {
            best_d = d;
            best = p;
        }
    }

    return best;
}

vec3 quantize_palette(vec3 c) {
#if PALETTE_KIND_VGA16 == 1
    return quantize_vga16(c, PALETTE_SIZE);
#elif PALETTE_KIND_CUBE256 == 1
    return quantize_cube256(c, PALETTE_SIZE);
#elif PALETTE_KIND_CUSTOM == 1
    return quantize_custom(c);
#else
    return c;
#endif
}

void main() {
    vec4 src = texture2D(tex, texcoord);
    vec3 lin;
    vec3 outc;

    /* PIPELINE_STEP_1_LINEARIZE */
    lin = srgb_to_linear(src.rgb);

    /* PIPELINE_STEP_2_TRANSFORM */
    lin = tone_transform(lin);

    outc = lin;

#if MODE_PASSTHROUGH == 1
    /* passthrough: quantization and dithering are intentionally skipped */
#else
    /* PIPELINE_STEP_3_QUANTIZE */
#if MODE_MONO == 1
    {
        float y = luminance(lin);
        float q = quantize_1d(y, MONO_BANDS);
        vec3 phosphor = vec3(PHOSPHOR_R, PHOSPHOR_G, PHOSPHOR_B);
        outc = phosphor * q;
#if HOTCORE == 1
        {
            float core = smoothstep(0.72, 1.0, q);
            outc = mix(outc, vec3(1.0), core * 0.65);
        }
#endif
    }
#elif MODE_PALETTE == 1
    outc = quantize_palette(lin);
#else
    outc = lin;
#endif

    /* PIPELINE_STEP_4_DITHER */
#if ENABLE_DITHER == 1
#if MODE_MONO == 1 || MODE_PALETTE == 1
    {
        float d = (bayer4(gl_FragCoord.xy) + 0.5) / 16.0;
        outc = clamp(outc + vec3((d - 0.5) * 0.03), 0.0, 1.0);
    }
#endif
#endif
#endif

    /* PIPELINE_STEP_5_SCANLINES */
#if ENABLE_SCANLINES == 1
    {
        float s = 0.985 + 0.015 * sin((gl_FragCoord.y + 0.5) * 3.14159265);
        outc *= s;
    }
#endif

    /* PIPELINE_STEP_6_FLICKER */
#if ENABLE_FLICKER == 1
    {
        float t = 1.0 + 0.015 * sin(time * 1.3);
        outc *= t;
    }
#endif

    /* PIPELINE_STEP_7_VIGNETTE */
#if ENABLE_VIGNETTE == 1
    {
        vec2 p = texcoord - vec2(0.5, 0.5);
        float v = 1.0 - dot(p, p) * 0.55;
        outc *= clamp(v, 0.82, 1.0);
    }
#endif

    outc = clamp(outc, 0.0, 1.0);

    /* PIPELINE_STEP_8_ENCODE */
    gl_FragColor = vec4(linear_to_srgb(outc), src.a * opacity);
}
