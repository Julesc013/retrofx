#!/usr/bin/env bash
set -euo pipefail

export LC_ALL=C

readonly SELF_SCRIPT_DIR="$(CDPATH= cd -- "$(dirname -- "${BASH_SOURCE[0]}")" && pwd)"
readonly SELF_ROOT_DIR="$(CDPATH= cd -- "$SELF_SCRIPT_DIR/.." && pwd)"

resolve_runtime_root() {
  local install_home
  install_home="${HOME}/.config/retrofx"

  if [[ -n "${RETROFX_HOME:-}" ]]; then
    if [[ -d "$RETROFX_HOME" ]]; then
      (CDPATH= cd -- "$RETROFX_HOME" && pwd)
    else
      printf '%s' "$RETROFX_HOME"
    fi
    return 0
  fi

  if [[ "$SELF_SCRIPT_DIR" == "${HOME}/.local/bin" && -d "$install_home" ]]; then
    printf '%s' "$install_home"
    return 0
  fi

  printf '%s' "$SELF_ROOT_DIR"
}

readonly ROOT_DIR="$(resolve_runtime_root)"
readonly SCRIPT_DIR="$ROOT_DIR/scripts"
readonly PROFILES_DIR="$ROOT_DIR/profiles"
readonly PROFILES_USER_DIR="$PROFILES_DIR/user"
readonly PROFILES_PACKS_DIR="$PROFILES_DIR/packs"
readonly TEMPLATES_DIR="$ROOT_DIR/templates"
readonly ACTIVE_DIR="$ROOT_DIR/active"
readonly STATE_DIR="$ROOT_DIR/state"
readonly BACKUPS_DIR="$STATE_DIR/backups"
readonly LAST_GOOD_DIR="$STATE_DIR/last_good"
readonly LOGS_DIR="$STATE_DIR/logs"
readonly AUDIT_LOG_FILE="$LOGS_DIR/retrofx.log"

readonly BACKEND_X11="$ROOT_DIR/backends/x11-picom/apply.sh"
readonly BACKEND_TTY="$ROOT_DIR/backends/tty/apply.sh"
readonly BACKEND_TUIGREET="$ROOT_DIR/backends/tuigreet/apply.sh"
readonly BACKUP_KEEP_DEFAULT=10
readonly DEFAULT_INSTALL_HOME="${HOME}/.config/retrofx"
readonly DEFAULT_LAUNCHER_PATH="${HOME}/.local/bin/retrofx"
readonly INSTALL_MARKER_FILE=".retrofx-install"
readonly XS_MARKER_KEY="X-RetroFX-Managed=true"
readonly VERSION_FILE="$ROOT_DIR/VERSION"

BACKUP_KEEP="${RETROFX_BACKUP_KEEP:-$BACKUP_KEEP_DEFAULT}"
if [[ ! "$BACKUP_KEEP" =~ ^[0-9]+$ ]] || ((BACKUP_KEEP < 1)); then
  BACKUP_KEEP="$BACKUP_KEEP_DEFAULT"
fi
readonly BACKUP_KEEP

umask 077

declare -A PARSE_SEEN_KEYS=()

declare LAST_ERROR=""
declare AUDIT_CMD=""
declare AUDIT_PROFILE="-"
declare AUDIT_ENABLED=0
declare TXN_ACTIVE=0
declare TXN_STAGE_DIR=""

declare CFG_PROFILE_PATH=""
declare CFG_name=""
declare CFG_version="1"
declare CFG_description=""
declare CFG_tags=""
declare CFG_author=""
declare CFG_license=""
declare CFG_mode_type="passthrough"

declare CFG_monochrome_bands="4"
declare CFG_monochrome_phosphor="green"
declare CFG_monochrome_custom_rgb=""
declare CFG_monochrome_hotcore="false"

declare CFG_palette_kind="vga16"
declare CFG_palette_size="16"
declare CFG_palette_custom_file=""

declare CFG_effects_blur_strength="2"
declare CFG_effects_scanlines="false"
declare CFG_effects_flicker="false"
declare CFG_effects_dither="none"
declare CFG_effects_vignette="false"
declare CFG_effects_scanline_preset=""
declare CFG_effects_transparency="off"

declare CFG_scope_x11="true"
declare CFG_scope_tty="false"
declare CFG_scope_tuigreet="false"

declare CFG_fonts_tty=""
declare CFG_fonts_terminal=""
declare CFG_fonts_terminal_fallback=""
declare CFG_fonts_ui=""
declare CFG_fontaa_antialias="default"
declare CFG_fontaa_subpixel="default"

declare CFG_phosphor_r="1.000000"
declare CFG_phosphor_g="1.000000"
declare CFG_phosphor_b="1.000000"
declare CFG_colors_background=""
declare CFG_colors_foreground=""
declare CFG_rules_exclude_wm_class=""
declare CFG_rules_exclude_wm_name=""
declare CFG_rules_exclude_opacity_below=""

declare -a ANSI_HEX=()
declare SEM_BACKGROUND="#000000"
declare SEM_NORMAL="#c0c0c0"
declare SEM_DIM="#606060"
declare SEM_BRIGHT="#ffffff"
declare SEM_INFO="#3a5fb0"
declare SEM_SUCCESS="#00aa00"
declare SEM_WARNING="#b0a000"
declare SEM_ERROR="#aa0000"
declare CFG_bg_tint_hex="#000000"
declare CFG_fg_tint_hex="#c0c0c0"
declare CFG_bg_tint_linear_r="0.000000"
declare CFG_bg_tint_linear_g="0.000000"
declare CFG_bg_tint_linear_b="0.000000"
declare CFG_scanline_base="0.985000"
declare CFG_scanline_amp="0.015000"

now_ts() {
  date -u +%Y-%m-%dT%H:%M:%SZ
}

now_ts_compact() {
  date -u +%Y%m%d-%H%M%S
}

expand_user_path() {
  local raw="$1"
  case "$raw" in
    "~")
      printf '%s' "$HOME"
      ;;
    "~/"*)
      printf '%s/%s' "$HOME" "${raw#~/}"
      ;;
    *)
      printf '%s' "$raw"
      ;;
  esac
}

execution_mode() {
  if [[ -f "$ROOT_DIR/$INSTALL_MARKER_FILE" ]]; then
    printf 'installed'
  else
    printf 'repo-local'
  fi
}

read_version() {
  local ver=""
  if [[ -f "$VERSION_FILE" ]]; then
    IFS= read -r ver <"$VERSION_FILE" || true
    ver="$(trim "$ver")"
  fi
  if [[ -z "$ver" ]]; then
    ver="0.0.0-unknown"
  fi
  printf '%s' "$ver"
}

capability_summary_line() {
  printf 'x11=full-with-picom+glx wayland=degraded'
}

append_home_log() {
  local home_dir="$1"
  local cmd="$2"
  local profile="$3"
  local result="$4"
  local detail="$5"

  (
    mkdir -p "$home_dir/state/logs"
    printf '%s cmd=%q profile=%q result=%q detail=%q\n' \
      "$(now_ts)" "$cmd" "$profile" "$result" "$detail" >>"$home_dir/state/logs/retrofx.log"
  ) >/dev/null 2>&1 || true
}

confirm_or_die() {
  local question="$1"
  local auto_yes="${2:-false}"
  local answer=""

  if [[ "$auto_yes" == "true" ]]; then
    return 0
  fi

  if [[ ! -t 0 ]]; then
    die "$question (use --yes to proceed in non-interactive mode)"
  fi

  read -r -p "$question [y/N]: " answer || die "aborted"
  case "$answer" in
    y | Y | yes | YES)
      return 0
      ;;
    *)
      die "aborted"
      ;;
  esac
}

ensure_dirs() {
  mkdir -p "$ACTIVE_DIR" "$STATE_DIR" "$BACKUPS_DIR" "$LOGS_DIR"
}

append_audit_log() {
  local result="$1"
  local detail="$2"
  local ts

  ts="$(now_ts)"
  (
    mkdir -p "$LOGS_DIR"
    printf '%s cmd=%q profile=%q result=%q detail=%q\n' \
      "$ts" "${AUDIT_CMD:-unknown}" "${AUDIT_PROFILE:-unknown}" "$result" "$detail" >>"$AUDIT_LOG_FILE"
  ) >/dev/null 2>&1 || true
}

audit_begin() {
  local cmd="$1"
  local profile="${2:--}"
  AUDIT_CMD="$cmd"
  AUDIT_PROFILE="$profile"
  AUDIT_ENABLED=1
}

audit_on_exit() {
  local rc="$1"

  if [[ "$TXN_ACTIVE" -eq 1 ]]; then
    [[ -n "$TXN_STAGE_DIR" ]] && rm -rf "$TXN_STAGE_DIR" >/dev/null 2>&1 || true
    if [[ "$rc" -ne 0 ]]; then
      restore_last_good || true
    fi
  fi

  if [[ "$AUDIT_ENABLED" -eq 1 ]]; then
    if [[ "$rc" -eq 0 ]]; then
      append_audit_log "success" "-"
    else
      append_audit_log "failure" "${LAST_ERROR:-exit=$rc}"
    fi
  fi
}

info() {
  printf 'retrofx: %s\n' "$*"
}

log() {
  info "$@"
}

warn() {
  printf 'retrofx: warning: %s\n' "$*" >&2
}

die() {
  LAST_ERROR="$*"
  printf 'retrofx: error: %s\n' "$*" >&2
  exit 1
}

trap 'audit_on_exit $?' EXIT

trim() {
  local s="$1"
  s="${s#"${s%%[![:space:]]*}"}"
  s="${s%"${s##*[![:space:]]}"}"
  printf '%s' "$s"
}

xml_escape() {
  local s="$1"
  s="${s//&/&amp;}"
  s="${s//</&lt;}"
  s="${s//>/&gt;}"
  s="${s//\"/&quot;}"
  s="${s//\'/&apos;}"
  printf '%s' "$s"
}

dir_has_files() {
  local dir="$1"
  [[ -d "$dir" && -n "$(find "$dir" -mindepth 1 -maxdepth 1 -print -quit 2>/dev/null)" ]]
}

strip_inline_comment() {
  local input="$1"
  local out=""
  local in_quote=0
  local prev=""
  local i c

  for ((i = 0; i < ${#input}; i++)); do
    c="${input:i:1}"
    if [[ "$c" == '"' && "$prev" != '\\' ]]; then
      if ((in_quote == 0)); then
        in_quote=1
      else
        in_quote=0
      fi
    fi
    if [[ "$c" == "#" && $in_quote -eq 0 ]]; then
      break
    fi
    out+="$c"
    prev="$c"
  done

  printf '%s' "$out"
}

toml_string() {
  local raw
  raw="$(trim "$1")"

  if [[ $raw =~ ^\".*\"$ ]]; then
    local inner="${raw:1:${#raw}-2}"
    inner="${inner//\\\\/\\}"
    inner="${inner//\\\"/\"}"
    printf '%s' "$inner"
    return 0
  fi

  if [[ "$raw" =~ ^[A-Za-z0-9._/:,+-]+$ ]]; then
    printf '%s' "$raw"
    return 0
  fi

  return 1
}

parse_bool() {
  local raw
  raw="$(trim "$1")"
  case "$raw" in
    true | false)
      printf '%s' "$raw"
      ;;
    *)
      return 1
      ;;
  esac
}

parse_int_range() {
  local raw min max
  raw="$(trim "$1")"
  min="$2"
  max="$3"

  if [[ ! "$raw" =~ ^[0-9]+$ ]]; then
    return 1
  fi

  if ((raw < min || raw > max)); then
    return 1
  fi

  printf '%s' "$raw"
}

parse_float_range() {
  local raw min max
  raw="$(trim "$1")"
  min="$2"
  max="$3"

  if [[ ! "$raw" =~ ^([0-9]+\.[0-9]+|[0-9]+|\.[0-9]+)$ ]]; then
    return 1
  fi

  awk -v x="$raw" -v lo="$min" -v hi="$max" 'BEGIN {
    if (x < lo || x > hi) exit 1;
    printf "%.6f", x;
  }' || return 1
}

parse_hex_color() {
  local raw
  raw="$(trim "$1")"

  if [[ "$raw" =~ ^\"#([A-Fa-f0-9]{6})\"$ ]]; then
    printf '#%s' "${BASH_REMATCH[1],,}"
    return 0
  fi

  if [[ "$raw" =~ ^#([A-Fa-f0-9]{6})$ ]]; then
    printf '#%s' "${BASH_REMATCH[1],,}"
    return 0
  fi

  return 1
}

parse_string_array() {
  local raw inner token val out=""
  raw="$(trim "$1")"

  [[ "$raw" == "["*"]" ]] || return 1
  inner="${raw:1:${#raw}-2}"
  inner="$(trim "$inner")"

  if [[ -z "$inner" ]]; then
    printf ''
    return 0
  fi

  while [[ -n "$inner" ]]; do
    if [[ "$inner" =~ ^\"([^\"\\]|\\.)*\" ]]; then
      token="${BASH_REMATCH[0]}"
      val="$(toml_string "$token")" || return 1
    elif [[ "$inner" =~ ^[A-Za-z0-9._:+-]+ ]]; then
      token="${BASH_REMATCH[0]}"
      val="$(toml_string "$token")" || return 1
    else
      return 1
    fi

    if [[ -z "$out" ]]; then
      out="$val"
    else
      out="$out,$val"
    fi

    inner="${inner:${#token}}"
    inner="$(trim "$inner")"
    if [[ -z "$inner" ]]; then
      break
    fi
    [[ "${inner:0:1}" == "," ]] || return 1
    inner="$(trim "${inner:1}")"
  done

  printf '%s' "$out"
}

normalize_rgb_component() {
  local raw
  raw="$(trim "$1")"

  if [[ "$raw" =~ ^[0-9]+$ ]]; then
    if ((raw < 0 || raw > 255)); then
      return 1
    fi
    awk -v c="$raw" 'BEGIN { printf "%.6f", c / 255.0 }'
    return 0
  fi

  if [[ "$raw" =~ ^([0-9]+\.[0-9]+|[0-9]+|\.[0-9]+)$ ]]; then
    awk -v c="$raw" 'BEGIN { if (c < 0.0 || c > 1.0) { exit 1 } printf "%.6f", c }' || return 1
    return 0
  fi

  return 1
}

normalize_rgb_triplet() {
  local raw c1 c2 c3 extra n1 n2 n3
  raw="$(trim "$1")"

  IFS=',' read -r c1 c2 c3 extra <<<"$raw"
  if [[ -n "${extra:-}" || -z "${c1:-}" || -z "${c2:-}" || -z "${c3:-}" ]]; then
    return 1
  fi

  n1="$(normalize_rgb_component "$c1")" || return 1
  n2="$(normalize_rgb_component "$c2")" || return 1
  n3="$(normalize_rgb_component "$c3")" || return 1
  printf '%s,%s,%s' "$n1" "$n2" "$n3"
}

require_seen() {
  local key="$1"
  local message="$2"
  if [[ -z "${PARSE_SEEN_KEYS[$key]:-}" ]]; then
    die "$message"
  fi
}

reset_config() {
  PARSE_SEEN_KEYS=()

  CFG_PROFILE_PATH=""
  CFG_name=""
  CFG_version="1"
  CFG_description=""
  CFG_tags=""
  CFG_author=""
  CFG_license=""
  CFG_mode_type="passthrough"

  CFG_monochrome_bands="4"
  CFG_monochrome_phosphor="green"
  CFG_monochrome_custom_rgb=""
  CFG_monochrome_hotcore="false"

  CFG_palette_kind="vga16"
  CFG_palette_size="16"
  CFG_palette_custom_file=""

  CFG_effects_blur_strength="2"
  CFG_effects_scanlines="false"
  CFG_effects_flicker="false"
  CFG_effects_dither="none"
  CFG_effects_vignette="false"
  CFG_effects_scanline_preset=""
  CFG_effects_transparency="off"

  CFG_scope_x11="true"
  CFG_scope_tty="false"
  CFG_scope_tuigreet="false"

  CFG_fonts_tty=""
  CFG_fonts_terminal=""
  CFG_fonts_terminal_fallback=""
  CFG_fonts_ui=""
  CFG_fontaa_antialias="default"
  CFG_fontaa_subpixel="default"

  CFG_phosphor_r="1.000000"
  CFG_phosphor_g="1.000000"
  CFG_phosphor_b="1.000000"
  CFG_colors_background=""
  CFG_colors_foreground=""
  CFG_rules_exclude_wm_class=""
  CFG_rules_exclude_wm_name=""
  CFG_rules_exclude_opacity_below=""
  CFG_bg_tint_hex="#000000"
  CFG_fg_tint_hex="#c0c0c0"
  CFG_bg_tint_linear_r="0.000000"
  CFG_bg_tint_linear_g="0.000000"
  CFG_bg_tint_linear_b="0.000000"
  CFG_scanline_base="0.985000"
  CFG_scanline_amp="0.015000"
}

set_cfg_value() {
  local section="$1"
  local key="$2"
  local raw="$3"
  local ctx="$4"
  local val

  case "$section" in
    "")
      case "$key" in
        name)
          val="$(toml_string "$raw")" || die "$ctx: invalid string for name"
          CFG_name="$val"
          ;;
        version)
          if val="$(parse_int_range "$raw" 1 1)"; then
            CFG_version="$val"
          else
            val="$(toml_string "$raw")" || die "$ctx: version must be 1"
            [[ "$val" == "1" ]] || die "$ctx: unsupported version '$val' (expected 1)"
            CFG_version="$val"
          fi
          ;;
        description)
          val="$(toml_string "$raw")" || die "$ctx: invalid string for description"
          CFG_description="$val"
          ;;
        tags)
          val="$(parse_string_array "$raw")" || die "$ctx: tags must be an array of strings"
          CFG_tags="$val"
          ;;
        author)
          val="$(toml_string "$raw")" || die "$ctx: invalid string for author"
          CFG_author="$val"
          ;;
        license)
          val="$(toml_string "$raw")" || die "$ctx: invalid string for license"
          CFG_license="$val"
          ;;
        *)
          die "$ctx: unknown top-level key '$key'"
          ;;
      esac
      ;;
    mode)
      case "$key" in
        type)
          val="$(toml_string "$raw")" || die "$ctx: invalid mode.type"
          case "$val" in
            passthrough | monochrome | palette)
              CFG_mode_type="$val"
              ;;
            *)
              die "$ctx: mode.type must be passthrough|monochrome|palette"
              ;;
          esac
          ;;
        *)
          die "$ctx: unknown key 'mode.$key'"
          ;;
      esac
      ;;
    monochrome)
      case "$key" in
        bands)
          val="$(parse_int_range "$raw" 2 256)" || die "$ctx: monochrome.bands must be 2..256"
          CFG_monochrome_bands="$val"
          ;;
        phosphor)
          val="$(toml_string "$raw")" || die "$ctx: invalid monochrome.phosphor"
          case "$val" in
            green | amber | blue | white | custom)
              CFG_monochrome_phosphor="$val"
              ;;
            *)
              die "$ctx: monochrome.phosphor must be green|amber|blue|white|custom"
              ;;
          esac
          ;;
        custom_rgb)
          val="$(toml_string "$raw")" || die "$ctx: invalid monochrome.custom_rgb"
          val="$(normalize_rgb_triplet "$val")" || die "$ctx: monochrome.custom_rgb must be r,g,b with each in 0..1 or 0..255"
          CFG_monochrome_custom_rgb="$val"
          ;;
        hotcore)
          val="$(parse_bool "$raw")" || die "$ctx: monochrome.hotcore must be true|false"
          CFG_monochrome_hotcore="$val"
          ;;
        *)
          die "$ctx: unknown key 'monochrome.$key'"
          ;;
      esac
      ;;
    palette)
      case "$key" in
        kind)
          val="$(toml_string "$raw")" || die "$ctx: invalid palette.kind"
          case "$val" in
            vga16 | mono2 | mono4 | mono8 | mono16 | cube32 | cube64 | cube128 | cube256 | custom)
              CFG_palette_kind="$val"
              ;;
            *)
              die "$ctx: palette.kind must be vga16|mono2|mono4|mono8|mono16|cube32|cube64|cube128|cube256|custom"
              ;;
          esac
          ;;
        size)
          val="$(parse_int_range "$raw" 2 256)" || die "$ctx: palette.size must be 2..256"
          CFG_palette_size="$val"
          ;;
        custom_file)
          val="$(toml_string "$raw")" || die "$ctx: invalid palette.custom_file"
          CFG_palette_custom_file="$val"
          ;;
        *)
          die "$ctx: unknown key 'palette.$key'"
          ;;
      esac
      ;;
    effects)
      case "$key" in
        blur_strength)
          val="$(parse_int_range "$raw" 0 6)" || die "$ctx: effects.blur_strength must be 0..6"
          CFG_effects_blur_strength="$val"
          ;;
        scanlines)
          val="$(parse_bool "$raw")" || die "$ctx: effects.scanlines must be true|false"
          CFG_effects_scanlines="$val"
          ;;
        flicker)
          val="$(parse_bool "$raw")" || die "$ctx: effects.flicker must be true|false"
          CFG_effects_flicker="$val"
          ;;
        dither)
          val="$(toml_string "$raw")" || die "$ctx: invalid effects.dither"
          case "$val" in
            none | ordered)
              CFG_effects_dither="$val"
              ;;
            *)
              die "$ctx: effects.dither must be none|ordered"
              ;;
          esac
          ;;
        vignette)
          val="$(parse_bool "$raw")" || die "$ctx: effects.vignette must be true|false"
          CFG_effects_vignette="$val"
          ;;
        scanline_preset)
          val="$(toml_string "$raw")" || die "$ctx: invalid effects.scanline_preset"
          case "$val" in
            blur_on | blur_off)
              CFG_effects_scanline_preset="$val"
              ;;
            *)
              die "$ctx: effects.scanline_preset must be blur_on|blur_off"
              ;;
          esac
          ;;
        transparency)
          val="$(toml_string "$raw")" || die "$ctx: invalid effects.transparency"
          case "$val" in
            off | on | rules)
              CFG_effects_transparency="$val"
              ;;
            *)
              die "$ctx: effects.transparency must be off|on|rules"
              ;;
          esac
          ;;
        *)
          die "$ctx: unknown key 'effects.$key'"
          ;;
      esac
      ;;
    scope)
      case "$key" in
        x11)
          val="$(parse_bool "$raw")" || die "$ctx: scope.x11 must be true|false"
          CFG_scope_x11="$val"
          ;;
        tty)
          val="$(parse_bool "$raw")" || die "$ctx: scope.tty must be true|false"
          CFG_scope_tty="$val"
          ;;
        tuigreet)
          val="$(parse_bool "$raw")" || die "$ctx: scope.tuigreet must be true|false"
          CFG_scope_tuigreet="$val"
          ;;
        *)
          die "$ctx: unknown key 'scope.$key'"
          ;;
      esac
      ;;
    fonts)
      case "$key" in
        tty)
          val="$(toml_string "$raw")" || die "$ctx: invalid fonts.tty"
          CFG_fonts_tty="$val"
          ;;
        terminal)
          val="$(toml_string "$raw")" || die "$ctx: invalid fonts.terminal"
          CFG_fonts_terminal="$val"
          ;;
        terminal_fallback)
          val="$(parse_string_array "$raw")" || die "$ctx: fonts.terminal_fallback must be an array of strings"
          CFG_fonts_terminal_fallback="$val"
          ;;
        ui)
          val="$(toml_string "$raw")" || die "$ctx: invalid fonts.ui"
          CFG_fonts_ui="$val"
          ;;
        *)
          die "$ctx: unknown key 'fonts.$key'"
          ;;
      esac
      ;;
    font_aa)
      case "$key" in
        antialias)
          val="$(toml_string "$raw")" || die "$ctx: invalid font_aa.antialias"
          case "$val" in
            default | on | off)
              CFG_fontaa_antialias="$val"
              ;;
            *)
              die "$ctx: font_aa.antialias must be default|on|off"
              ;;
          esac
          ;;
        subpixel)
          val="$(toml_string "$raw")" || die "$ctx: invalid font_aa.subpixel"
          case "$val" in
            default | rgb | bgr | none)
              CFG_fontaa_subpixel="$val"
              ;;
            *)
              die "$ctx: font_aa.subpixel must be default|rgb|bgr|none"
              ;;
          esac
          ;;
        *)
          die "$ctx: unknown key 'font_aa.$key'"
          ;;
      esac
      ;;
    colors)
      case "$key" in
        background)
          val="$(parse_hex_color "$raw")" || die "$ctx: colors.background must be #RRGGBB"
          CFG_colors_background="$val"
          ;;
        foreground)
          val="$(parse_hex_color "$raw")" || die "$ctx: colors.foreground must be #RRGGBB"
          CFG_colors_foreground="$val"
          ;;
        *)
          die "$ctx: unknown key 'colors.$key'"
          ;;
      esac
      ;;
    rules)
      case "$key" in
        exclude_wm_class)
          val="$(parse_string_array "$raw")" || die "$ctx: rules.exclude_wm_class must be an array of strings"
          CFG_rules_exclude_wm_class="$val"
          ;;
        exclude_wm_name)
          val="$(parse_string_array "$raw")" || die "$ctx: rules.exclude_wm_name must be an array of strings"
          CFG_rules_exclude_wm_name="$val"
          ;;
        exclude_opacity_below)
          val="$(parse_float_range "$raw" 0 1)" || die "$ctx: rules.exclude_opacity_below must be 0..1"
          CFG_rules_exclude_opacity_below="$val"
          ;;
        *)
          die "$ctx: unknown key 'rules.$key'"
          ;;
      esac
      ;;
    *)
      die "$ctx: unknown section '$section'"
      ;;
  esac
}

parse_profile() {
  local profile_path="$1"
  local line line_no=0 section=""

  reset_config
  CFG_PROFILE_PATH="$profile_path"

  [[ -f "$profile_path" ]] || die "profile does not exist: $profile_path"

  while IFS= read -r line || [[ -n "$line" ]]; do
    line_no=$((line_no + 1))
    line="${line%$'\r'}"
    line="$(strip_inline_comment "$line")"
    line="$(trim "$line")"

    [[ -z "$line" ]] && continue

    if [[ "$line" =~ ^\[([A-Za-z0-9_]+)\]$ ]]; then
      section="${BASH_REMATCH[1]}"
      case "$section" in
        mode | monochrome | palette | effects | scope | fonts | font_aa | colors | rules)
          ;;
        *)
          die "$profile_path:$line_no: unknown section [$section]"
          ;;
      esac
      continue
    fi

    if [[ ! "$line" =~ ^([A-Za-z0-9_]+)[[:space:]]*=[[:space:]]*(.+)$ ]]; then
      die "$profile_path:$line_no: invalid TOML syntax"
    fi

    local key="${BASH_REMATCH[1]}"
    local raw="${BASH_REMATCH[2]}"
    local scope_key

    if [[ -n "$section" ]]; then
      scope_key="$section.$key"
    else
      scope_key="root.$key"
    fi

    if [[ -n "${PARSE_SEEN_KEYS[$scope_key]:-}" ]]; then
      die "$profile_path:$line_no: duplicate key '$scope_key'"
    fi
    PARSE_SEEN_KEYS[$scope_key]=1

    set_cfg_value "$section" "$key" "$raw" "$profile_path:$line_no"
  done <"$profile_path"

  require_seen "root.name" "$profile_path: missing required top-level key 'name'"
  require_seen "root.version" "$profile_path: missing required top-level key 'version'"
  require_seen "mode.type" "$profile_path: missing required key 'mode.type'"
  require_seen "effects.blur_strength" "$profile_path: missing required key 'effects.blur_strength'"
  require_seen "effects.scanlines" "$profile_path: missing required key 'effects.scanlines'"
  require_seen "effects.flicker" "$profile_path: missing required key 'effects.flicker'"
  require_seen "effects.dither" "$profile_path: missing required key 'effects.dither'"
  require_seen "effects.vignette" "$profile_path: missing required key 'effects.vignette'"
  require_seen "scope.x11" "$profile_path: missing required key 'scope.x11'"
  require_seen "scope.tty" "$profile_path: missing required key 'scope.tty'"
  require_seen "scope.tuigreet" "$profile_path: missing required key 'scope.tuigreet'"

  case "$CFG_mode_type" in
    monochrome)
      require_seen "monochrome.bands" "$profile_path: mode=monochrome requires monochrome.bands"
      require_seen "monochrome.phosphor" "$profile_path: mode=monochrome requires monochrome.phosphor"
      require_seen "monochrome.hotcore" "$profile_path: mode=monochrome requires monochrome.hotcore"
      if [[ "$CFG_monochrome_phosphor" == "custom" ]]; then
        require_seen "monochrome.custom_rgb" "$profile_path: phosphor=custom requires monochrome.custom_rgb"
      fi
      ;;
    palette)
      require_seen "palette.kind" "$profile_path: mode=palette requires palette.kind"
      require_seen "palette.size" "$profile_path: mode=palette requires palette.size"
      if [[ "$CFG_palette_kind" == "custom" ]]; then
        require_seen "palette.custom_file" "$profile_path: palette.kind=custom requires palette.custom_file"
        if ((CFG_palette_size > 32)); then
          die "$profile_path: palette.kind=custom supports size up to 32"
        fi
      fi

      case "$CFG_palette_kind" in
        mono2)
          ((CFG_palette_size == 2)) || die "$profile_path: palette.kind=mono2 requires size=2"
          ;;
        mono4)
          ((CFG_palette_size == 4)) || die "$profile_path: palette.kind=mono4 requires size=4"
          ;;
        mono8)
          ((CFG_palette_size == 8)) || die "$profile_path: palette.kind=mono8 requires size=8"
          ;;
        mono16)
          ((CFG_palette_size == 16)) || die "$profile_path: palette.kind=mono16 requires size=16"
          ;;
        cube32)
          ((CFG_palette_size == 32)) || die "$profile_path: palette.kind=cube32 requires size=32"
          ;;
        cube64)
          ((CFG_palette_size == 64)) || die "$profile_path: palette.kind=cube64 requires size=64"
          ;;
        cube128)
          ((CFG_palette_size == 128)) || die "$profile_path: palette.kind=cube128 requires size=128"
          ;;
        cube256)
          ((CFG_palette_size == 256)) || die "$profile_path: palette.kind=cube256 requires size=256"
          ;;
      esac
      ;;
    passthrough)
      ;;
  esac

  if ((CFG_effects_blur_strength > 3)); then
    warn "$profile_path: blur_strength > 3 can hurt performance"
  fi
}

resolve_profile_path() {
  local ref="$1"
  local path base

  if [[ -f "$ref" ]]; then
    printf '%s' "$ref"
    return 0
  fi

  if [[ -f "$PROFILES_USER_DIR/$ref" ]]; then
    printf '%s' "$PROFILES_USER_DIR/$ref"
    return 0
  fi

  if [[ -f "$PROFILES_USER_DIR/$ref.toml" ]]; then
    printf '%s' "$PROFILES_USER_DIR/$ref.toml"
    return 0
  fi

  if [[ -f "$PROFILES_PACKS_DIR/$ref" ]]; then
    printf '%s' "$PROFILES_PACKS_DIR/$ref"
    return 0
  fi

  if [[ -f "$PROFILES_PACKS_DIR/$ref.toml" ]]; then
    printf '%s' "$PROFILES_PACKS_DIR/$ref.toml"
    return 0
  fi

  if [[ -d "$PROFILES_PACKS_DIR" ]]; then
    while IFS= read -r path; do
      base="$(basename "$path")"
      base="${base%.toml}"
      if [[ "$base" == "$ref" ]]; then
        printf '%s' "$path"
        return 0
      fi
    done < <(find "$PROFILES_PACKS_DIR" -type f -name '*.toml' | sort)
  fi

  if [[ -f "$PROFILES_DIR/$ref" ]]; then
    printf '%s' "$PROFILES_DIR/$ref"
    return 0
  fi

  if [[ -f "$PROFILES_DIR/$ref.toml" ]]; then
    printf '%s' "$PROFILES_DIR/$ref.toml"
    return 0
  fi

  return 1
}

detect_x11() {
  [[ "$(detect_session_type)" == "x11" ]]
}

detect_wayland() {
  [[ "$(detect_session_type)" == "wayland" ]]
}

detect_session_type() {
  local xdg_type
  xdg_type="$(printf '%s' "${XDG_SESSION_TYPE:-}" | tr '[:upper:]' '[:lower:]')"

  if [[ -n "${WAYLAND_DISPLAY:-}" || "$xdg_type" == "wayland" ]]; then
    printf 'wayland'
    return 0
  fi

  if [[ -n "${DISPLAY:-}" || "$xdg_type" == "x11" ]]; then
    printf 'x11'
    return 0
  fi

  printf 'unknown'
}

detect_wm_de() {
  local desk
  desk="$(printf '%s:%s' "${XDG_CURRENT_DESKTOP:-}" "${DESKTOP_SESSION:-}" | tr '[:upper:]' '[:lower:]')"

  if [[ -n "${SWAYSOCK:-}" || "$desk" == *sway* ]]; then
    printf 'sway'
    return 0
  fi

  if [[ -n "${I3SOCK:-}" || "$desk" == *i3* ]]; then
    printf 'i3'
    return 0
  fi

  if [[ "$desk" == *plasma* || "$desk" == *kde* ]]; then
    printf 'plasma'
    return 0
  fi

  if [[ "$desk" == *gnome* ]]; then
    printf 'gnome'
    return 0
  fi

  if [[ "$desk" == *xfce* ]]; then
    printf 'xfce'
    return 0
  fi

  if [[ "$desk" == *awesome* ]]; then
    printf 'awesome'
    return 0
  fi

  if [[ "$desk" == *hyprland* ]]; then
    printf 'hyprland'
    return 0
  fi

  if command -v pgrep >/dev/null 2>&1; then
    if pgrep -x i3 >/dev/null 2>&1; then
      printf 'i3'
      return 0
    fi
    if pgrep -x sway >/dev/null 2>&1; then
      printf 'sway'
      return 0
    fi
    if pgrep -x plasmashell >/dev/null 2>&1; then
      printf 'plasma'
      return 0
    fi
    if pgrep -x gnome-shell >/dev/null 2>&1; then
      printf 'gnome'
      return 0
    fi
    if pgrep -x xfce4-session >/dev/null 2>&1; then
      printf 'xfce'
      return 0
    fi
    if pgrep -x awesome >/dev/null 2>&1; then
      printf 'awesome'
      return 0
    fi
  fi

  printf 'unknown'
}

picom_has_glx() {
  if ! command -v picom >/dev/null 2>&1; then
    return 1
  fi
  picom --help 2>&1 | grep -qi 'glx'
}

validate_profile() {
  local profile_path="$1"
  parse_profile "$profile_path"
}

load_profile() {
  local profile_path="$1"
  validate_profile "$profile_path"
  compute_phosphor_rgb
  compute_color_knobs
  compute_scanline_knobs
}

compute_phosphor_rgb() {
  if [[ "$CFG_mode_type" != "monochrome" ]]; then
    CFG_phosphor_r="1.000000"
    CFG_phosphor_g="1.000000"
    CFG_phosphor_b="1.000000"
    return 0
  fi

  case "$CFG_monochrome_phosphor" in
    green)
      CFG_phosphor_r="0.660000"
      CFG_phosphor_g="1.000000"
      CFG_phosphor_b="0.660000"
      ;;
    amber)
      CFG_phosphor_r="1.000000"
      CFG_phosphor_g="0.760000"
      CFG_phosphor_b="0.340000"
      ;;
    blue)
      CFG_phosphor_r="0.620000"
      CFG_phosphor_g="0.790000"
      CFG_phosphor_b="1.000000"
      ;;
    white)
      CFG_phosphor_r="1.000000"
      CFG_phosphor_g="1.000000"
      CFG_phosphor_b="1.000000"
      ;;
    custom)
      IFS=',' read -r CFG_phosphor_r CFG_phosphor_g CFG_phosphor_b <<<"$CFG_monochrome_custom_rgb"
      ;;
    *)
      die "internal error: unknown phosphor '$CFG_monochrome_phosphor'"
      ;;
  esac
}

compute_color_knobs() {
  local bg_hex fg_hex lin
  local base_scale="0.060000"

  if [[ -n "$CFG_colors_background" ]]; then
    bg_hex="$CFG_colors_background"
  else
    if [[ "$CFG_mode_type" == "monochrome" ]]; then
      bg_hex="$(awk -v r="$CFG_phosphor_r" -v g="$CFG_phosphor_g" -v b="$CFG_phosphor_b" -v s="$base_scale" 'BEGIN {
        rr = r * s; gg = g * s; bb = b * s;
        if (rr < 0.005) rr = 0.005;
        if (gg < 0.005) gg = 0.005;
        if (bb < 0.005) bb = 0.005;
        printf "#%02x%02x%02x", int(rr * 255.0 + 0.5), int(gg * 255.0 + 0.5), int(bb * 255.0 + 0.5);
      }')"
    else
      bg_hex="#060606"
    fi
  fi

  if [[ -n "$CFG_colors_foreground" ]]; then
    fg_hex="$CFG_colors_foreground"
  else
    if [[ "$CFG_mode_type" == "monochrome" ]]; then
      fg_hex="$(awk -v r="$CFG_phosphor_r" -v g="$CFG_phosphor_g" -v b="$CFG_phosphor_b" 'BEGIN {
        rr = r * 0.90; gg = g * 0.90; bb = b * 0.90;
        if (rr > 1.0) rr = 1.0;
        if (gg > 1.0) gg = 1.0;
        if (bb > 1.0) bb = 1.0;
        printf "#%02x%02x%02x", int(rr * 255.0 + 0.5), int(gg * 255.0 + 0.5), int(bb * 255.0 + 0.5);
      }')"
    else
      fg_hex="#c0c0c0"
    fi
  fi

  CFG_bg_tint_hex="$bg_hex"
  CFG_fg_tint_hex="$fg_hex"

  lin="$(hex_to_linear_triplet "$CFG_bg_tint_hex")" || die "internal error: invalid background tint color"
  IFS=',' read -r CFG_bg_tint_linear_r CFG_bg_tint_linear_g CFG_bg_tint_linear_b <<<"$lin"
}

compute_scanline_knobs() {
  local preset="$CFG_effects_scanline_preset"

  if [[ -z "$preset" ]]; then
    if ((CFG_effects_blur_strength > 0)); then
      preset="blur_on"
    else
      preset="blur_off"
    fi
  fi

  case "$preset" in
    blur_on)
      CFG_scanline_base="0.992000"
      CFG_scanline_amp="0.008000"
      ;;
    blur_off)
      CFG_scanline_base="0.978000"
      CFG_scanline_amp="0.022000"
      ;;
    *)
      CFG_scanline_base="0.985000"
      CFG_scanline_amp="0.015000"
      ;;
  esac
}

float_to_u8() {
  local n="$1"
  awk -v x="$n" 'BEGIN { v = int((x * 255.0) + 0.5); if (v < 0) v = 0; if (v > 255) v = 255; printf "%d", v }'
}

rgb_hex_from_units() {
  local r="$1"
  local g="$2"
  local b="$3"
  local ru gu bu

  ru="$(float_to_u8 "$r")"
  gu="$(float_to_u8 "$g")"
  bu="$(float_to_u8 "$b")"
  printf '#%02x%02x%02x' "$ru" "$gu" "$bu"
}

srgb_component_to_linear() {
  local c="$1"
  awk -v x="$c" 'BEGIN { printf "%.6f", (x ^ 2.2) }'
}

hex_to_unit_triplet() {
  local hex="${1#\#}"
  local r g b
  [[ "${#hex}" -eq 6 ]] || return 1
  r=$((16#${hex:0:2}))
  g=$((16#${hex:2:2}))
  b=$((16#${hex:4:2}))
  awk -v rr="$r" -v gg="$g" -v bb="$b" 'BEGIN {
    printf "%.6f,%.6f,%.6f", rr / 255.0, gg / 255.0, bb / 255.0
  }'
}

hex_to_linear_triplet() {
  local units ur ug ub lr lg lb
  units="$(hex_to_unit_triplet "$1")" || return 1
  IFS=',' read -r ur ug ub <<<"$units"
  lr="$(srgb_component_to_linear "$ur")"
  lg="$(srgb_component_to_linear "$ug")"
  lb="$(srgb_component_to_linear "$ub")"
  printf '%s,%s,%s' "$lr" "$lg" "$lb"
}

write_profile_env() {
  local out_file="$1"
  local profile_id

  profile_id="$(basename "$CFG_PROFILE_PATH")"
  profile_id="${profile_id%.toml}"

  {
    printf 'PROFILE_PATH=%q\n' "$CFG_PROFILE_PATH"
    printf 'PROFILE_ID=%q\n' "$profile_id"
    printf 'PROFILE_NAME=%q\n' "$CFG_name"
    printf 'PROFILE_VERSION=%q\n' "$CFG_version"
    printf 'PROFILE_DESCRIPTION=%q\n' "$CFG_description"
    printf 'PROFILE_TAGS=%q\n' "$CFG_tags"
    printf 'PROFILE_AUTHOR=%q\n' "$CFG_author"
    printf 'PROFILE_LICENSE=%q\n' "$CFG_license"

    printf 'MODE_TYPE=%q\n' "$CFG_mode_type"

    printf 'MONO_BANDS=%q\n' "$CFG_monochrome_bands"
    printf 'MONO_PHOSPHOR=%q\n' "$CFG_monochrome_phosphor"
    printf 'MONO_HOTCORE=%q\n' "$CFG_monochrome_hotcore"
    printf 'MONO_CUSTOM_RGB=%q\n' "$CFG_monochrome_custom_rgb"

    printf 'PALETTE_KIND=%q\n' "$CFG_palette_kind"
    printf 'PALETTE_SIZE=%q\n' "$CFG_palette_size"
    printf 'PALETTE_CUSTOM_FILE=%q\n' "$CFG_palette_custom_file"

    printf 'EFFECT_BLUR_STRENGTH=%q\n' "$CFG_effects_blur_strength"
    printf 'EFFECT_SCANLINES=%q\n' "$CFG_effects_scanlines"
    printf 'EFFECT_FLICKER=%q\n' "$CFG_effects_flicker"
    printf 'EFFECT_DITHER=%q\n' "$CFG_effects_dither"
    printf 'EFFECT_VIGNETTE=%q\n' "$CFG_effects_vignette"
    printf 'EFFECT_SCANLINE_PRESET=%q\n' "$CFG_effects_scanline_preset"
    printf 'EFFECT_TRANSPARENCY=%q\n' "$CFG_effects_transparency"

    printf 'SCOPE_X11=%q\n' "$CFG_scope_x11"
    printf 'SCOPE_TTY=%q\n' "$CFG_scope_tty"
    printf 'SCOPE_TUIGREET=%q\n' "$CFG_scope_tuigreet"

    printf 'FONT_TTY=%q\n' "$CFG_fonts_tty"
    printf 'FONT_TERMINAL=%q\n' "$CFG_fonts_terminal"
    printf 'FONT_TERMINAL_FALLBACK=%q\n' "$CFG_fonts_terminal_fallback"
    printf 'FONT_UI=%q\n' "$CFG_fonts_ui"
    printf 'FONT_AA_ANTIALIAS=%q\n' "$CFG_fontaa_antialias"
    printf 'FONT_AA_SUBPIXEL=%q\n' "$CFG_fontaa_subpixel"

    printf 'PHOSPHOR_R=%q\n' "$CFG_phosphor_r"
    printf 'PHOSPHOR_G=%q\n' "$CFG_phosphor_g"
    printf 'PHOSPHOR_B=%q\n' "$CFG_phosphor_b"
    printf 'COLOR_BACKGROUND=%q\n' "$CFG_colors_background"
    printf 'COLOR_FOREGROUND=%q\n' "$CFG_colors_foreground"
    printf 'RULES_EXCLUDE_WM_CLASS=%q\n' "$CFG_rules_exclude_wm_class"
    printf 'RULES_EXCLUDE_WM_NAME=%q\n' "$CFG_rules_exclude_wm_name"
    printf 'RULES_EXCLUDE_OPACITY_BELOW=%q\n' "$CFG_rules_exclude_opacity_below"
  } >"$out_file"
}

hex_from_u8_triplet() {
  local r="$1"
  local g="$2"
  local b="$3"
  printf '#%02x%02x%02x' "$r" "$g" "$b"
}

hex_to_rgb_triplet() {
  local hex="${1#\#}"
  local r g b
  [[ "${#hex}" -eq 6 ]] || return 1
  r=$((16#${hex:0:2}))
  g=$((16#${hex:2:2}))
  b=$((16#${hex:4:2}))
  printf '%d,%d,%d' "$r" "$g" "$b"
}

brightness_from_hex() {
  local hex="${1#\#}"
  local r g b
  [[ "${#hex}" -eq 6 ]] || return 1
  r=$((16#${hex:0:2}))
  g=$((16#${hex:2:2}))
  b=$((16#${hex:4:2}))
  printf '%d' $(((299 * r + 587 * g + 114 * b) / 1000))
}

mono_hex_for_fraction() {
  local frac="$1"
  awk \
    -v f="$frac" \
    -v bands="$CFG_monochrome_bands" \
    -v pr="$CFG_phosphor_r" \
    -v pg="$CFG_phosphor_g" \
    -v pb="$CFG_phosphor_b" '
    BEGIN {
      if (bands < 2) bands = 2;
      if (bands > 256) bands = 256;
      if (f < 0.0) f = 0.0;
      if (f > 1.0) f = 1.0;
      q = int((f * (bands - 1)) + 0.5) / (bands - 1);
      r = int((q * pr * 255.0) + 0.5);
      g = int((q * pg * 255.0) + 0.5);
      b = int((q * pb * 255.0) + 0.5);
      if (r < 0) r = 0; if (r > 255) r = 255;
      if (g < 0) g = 0; if (g > 255) g = 255;
      if (b < 0) b = 0; if (b > 255) b = 255;
      printf "#%02x%02x%02x", r, g, b;
    }'
}

set_vga16_palette() {
  ANSI_HEX=(
    "#000000" "#aa0000" "#00aa00" "#aa5500"
    "#0000aa" "#aa00aa" "#00aaaa" "#aaaaaa"
    "#555555" "#ff5555" "#55ff55" "#ffff55"
    "#5555ff" "#ff55ff" "#55ffff" "#ffffff"
  )
}

set_cube256_summary_palette() {
  ANSI_HEX=(
    "#000000" "#cc0000" "#00cc00" "#cccc00"
    "#0000cc" "#cc00cc" "#00cccc" "#d0d0d0"
    "#555555" "#ff4444" "#44ff44" "#ffff44"
    "#4444ff" "#ff44ff" "#44ffff" "#ffffff"
  )
}

set_monochrome_palette() {
  local -a fractions=(
    "0.00" "1.00" "0.60" "0.82"
    "0.45" "0.70" "0.66" "0.76"
    "0.28" "1.00" "0.78" "0.90"
    "0.58" "0.86" "0.84" "1.00"
  )
  local i

  ANSI_HEX=()
  for ((i = 0; i < 16; i++)); do
    ANSI_HEX+=("$(mono_hex_for_fraction "${fractions[$i]}")")
  done
}

set_monochrome_palette_with_bands() {
  local bands="$1"
  local old_bands="$CFG_monochrome_bands"
  CFG_monochrome_bands="$bands"
  set_monochrome_palette
  CFG_monochrome_bands="$old_bands"
}

resolve_custom_palette_path() {
  local custom_path="$CFG_palette_custom_file"
  local profile_dir

  [[ -n "$custom_path" ]] || return 1
  if [[ "$custom_path" == /* ]]; then
    printf '%s' "$custom_path"
    return 0
  fi

  [[ -n "$CFG_PROFILE_PATH" ]] || return 1
  profile_dir="$(CDPATH= cd -- "$(dirname -- "$CFG_PROFILE_PATH")" && pwd)"
  printf '%s/%s' "$profile_dir" "$custom_path"
}

declare -a PALETTE_HEX_LINES=()

load_palette_hex_lines() {
  local path="$1"
  local wanted="$2"
  local line parsed r g b hex

  PALETTE_HEX_LINES=()
  [[ -f "$path" ]] || return 1
  [[ "$wanted" =~ ^[0-9]+$ ]] || return 1

  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%$'\r'}"
    line="$(trim "$line")"
    [[ -z "$line" ]] && continue

    # "# " prefix denotes a comment line.
    if [[ "$line" == "# "* ]]; then
      continue
    fi

    if [[ "$line" =~ ^#([A-Fa-f0-9]{6})$ ]]; then
      hex="#${BASH_REMATCH[1],,}"
    elif [[ "$line" == *","*","* ]]; then
      parsed="$(normalize_rgb_triplet "$line")" || return 1
      IFS=',' read -r r g b <<<"$parsed"
      hex="$(rgb_hex_from_units "$r" "$g" "$b")"
    elif [[ "$line" =~ ^[0-9.]+[[:space:]]+[0-9.]+[[:space:]]+[0-9.]+$ ]]; then
      parsed="$(normalize_rgb_triplet "${line//[[:space:]]/,}")" || return 1
      IFS=',' read -r r g b <<<"$parsed"
      hex="$(rgb_hex_from_units "$r" "$g" "$b")"
    else
      return 1
    fi

    PALETTE_HEX_LINES+=("$hex")
    if ((${#PALETTE_HEX_LINES[@]} == wanted)); then
      break
    fi
  done <"$path"

  ((${#PALETTE_HEX_LINES[@]} >= wanted))
}

set_custom_palette_summary() {
  local custom_path=""
  local i

  if ((CFG_palette_size < 16)); then
    set_cube256_summary_palette
    return 0
  fi

  custom_path="$(resolve_custom_palette_path || true)"
  if [[ -z "$custom_path" ]]; then
    set_cube256_summary_palette
    return 0
  fi

  if ! load_palette_hex_lines "$custom_path" 16; then
    warn "unable to load first 16 entries from custom palette for ANSI summary: $custom_path"
    set_cube256_summary_palette
    return 0
  fi

  ANSI_HEX=()
  for ((i = 0; i < 16; i++)); do
    ANSI_HEX+=("${PALETTE_HEX_LINES[$i]}")
  done
}

build_ansi_palette() {
  case "$CFG_mode_type" in
    monochrome)
      set_monochrome_palette
      ;;
    palette)
      case "$CFG_palette_kind" in
        vga16)
          set_vga16_palette
          ;;
        mono2)
          set_monochrome_palette_with_bands 2
          ;;
        mono4)
          set_monochrome_palette_with_bands 4
          ;;
        mono8)
          set_monochrome_palette_with_bands 8
          ;;
        mono16)
          set_monochrome_palette_with_bands 16
          ;;
        cube32 | cube64 | cube128 | cube256)
          set_cube256_summary_palette
          ;;
        custom)
          set_custom_palette_summary
          ;;
      esac
      ;;
    passthrough)
      set_vga16_palette
      ;;
    *)
      set_vga16_palette
      ;;
  esac

  if [[ -n "${CFG_bg_tint_hex:-}" ]]; then
    ANSI_HEX[0]="$CFG_bg_tint_hex"
  fi
  if [[ -n "${CFG_fg_tint_hex:-}" ]]; then
    ANSI_HEX[7]="$CFG_fg_tint_hex"
  fi

  SEM_BACKGROUND="${ANSI_HEX[0]}"
  SEM_NORMAL="${ANSI_HEX[7]}"
  SEM_DIM="${ANSI_HEX[8]}"
  SEM_BRIGHT="${ANSI_HEX[15]}"
  SEM_INFO="${ANSI_HEX[4]}"
  SEM_SUCCESS="${ANSI_HEX[2]}"
  SEM_WARNING="${ANSI_HEX[3]}"
  SEM_ERROR="${ANSI_HEX[1]}"
}

write_semantic_env() {
  local out_file="$1"
  local i

  {
    for ((i = 0; i < 16; i++)); do
      printf 'ANSI_%d=%q\n' "$i" "${ANSI_HEX[$i]}"
    done
    printf 'SEM_BACKGROUND=%q\n' "$SEM_BACKGROUND"
    printf 'SEM_NORMAL=%q\n' "$SEM_NORMAL"
    printf 'SEM_DIM=%q\n' "$SEM_DIM"
    printf 'SEM_BRIGHT=%q\n' "$SEM_BRIGHT"
    printf 'SEM_INFO=%q\n' "$SEM_INFO"
    printf 'SEM_SUCCESS=%q\n' "$SEM_SUCCESS"
    printf 'SEM_WARNING=%q\n' "$SEM_WARNING"
    printf 'SEM_ERROR=%q\n' "$SEM_ERROR"
    printf 'MODE_TYPE=%q\n' "$CFG_mode_type"
    printf 'MONO_BANDS=%q\n' "$CFG_monochrome_bands"
    printf 'PALETTE_KIND=%q\n' "$CFG_palette_kind"
    printf 'PALETTE_SIZE=%q\n' "$CFG_palette_size"
  } >"$out_file"
}

write_tty_palette_text() {
  local out_file="$1"
  local i

  {
    printf '# RetroFX ANSI16 palette\n'
    printf '# index hex\n'
    for ((i = 0; i < 16; i++)); do
      printf '%d %s\n' "$i" "${ANSI_HEX[$i]}"
    done
    printf '# semantic\n'
    printf 'background %s\n' "$SEM_BACKGROUND"
    printf 'normal %s\n' "$SEM_NORMAL"
    printf 'dim %s\n' "$SEM_DIM"
    printf 'bright %s\n' "$SEM_BRIGHT"
    printf 'info %s\n' "$SEM_INFO"
    printf 'success %s\n' "$SEM_SUCCESS"
    printf 'warning %s\n' "$SEM_WARNING"
    printf 'error %s\n' "$SEM_ERROR"
  } >"$out_file"
}

render_xresources() {
  local out_file="$1"
  local line i placeholder

  : >"$out_file"
  while IFS= read -r line || [[ -n "$line" ]]; do
    for ((i = 0; i < 16; i++)); do
      placeholder="@ANSI${i}@"
      line="${line//$placeholder/${ANSI_HEX[$i]}}"
    done
    line="${line//@SEM_BACKGROUND@/$SEM_BACKGROUND}"
    line="${line//@SEM_NORMAL@/$SEM_NORMAL}"
    line="${line//@SEM_DIM@/$SEM_DIM}"
    line="${line//@SEM_BRIGHT@/$SEM_BRIGHT}"
    line="${line//@SEM_INFO@/$SEM_INFO}"
    line="${line//@SEM_SUCCESS@/$SEM_SUCCESS}"
    line="${line//@SEM_WARNING@/$SEM_WARNING}"
    line="${line//@SEM_ERROR@/$SEM_ERROR}"
    printf '%s\n' "$line" >>"$out_file"
  done <"$TEMPLATES_DIR/xresources.in"
}

render_alacritty() {
  local out_file="$1"
  local font_family font_size fallback_csv fallback_comment

  font_family="${CFG_fonts_terminal:-monospace}"
  font_size="11.0"
  fallback_csv="${CFG_fonts_terminal_fallback:-}"
  fallback_comment=""
  if [[ -n "$fallback_csv" ]]; then
    fallback_comment="# terminal_fallback: ${fallback_csv//,/, }"
  fi

  {
    printf '# RetroFX generated Alacritty config\n'
    printf '# Source profile: %s\n' "$CFG_name"
    [[ -n "$fallback_comment" ]] && printf '%s\n' "$fallback_comment"
    printf '\n[font]\n'
    printf 'size = %s\n' "$font_size"
    printf '\n[font.normal]\n'
    printf 'family = "%s"\n' "$font_family"
    printf 'style = "Regular"\n'
    printf '\n[cursor]\n'
    printf 'style = { shape = "Block", blinking = "Off" }\n'
    printf '\n[colors.primary]\n'
    printf 'background = "%s"\n' "$SEM_BACKGROUND"
    printf 'foreground = "%s"\n' "$SEM_NORMAL"
    printf '\n[colors.cursor]\n'
    printf 'text = "%s"\n' "$SEM_BACKGROUND"
    printf 'cursor = "%s"\n' "$SEM_BRIGHT"
    printf '\n[colors.selection]\n'
    printf 'text = "%s"\n' "$SEM_BACKGROUND"
    printf 'background = "%s"\n' "$SEM_BRIGHT"
    printf '\n[colors.normal]\n'
    printf 'black = "%s"\n' "${ANSI_HEX[0]}"
    printf 'red = "%s"\n' "${ANSI_HEX[1]}"
    printf 'green = "%s"\n' "${ANSI_HEX[2]}"
    printf 'yellow = "%s"\n' "${ANSI_HEX[3]}"
    printf 'blue = "%s"\n' "${ANSI_HEX[4]}"
    printf 'magenta = "%s"\n' "${ANSI_HEX[5]}"
    printf 'cyan = "%s"\n' "${ANSI_HEX[6]}"
    printf 'white = "%s"\n' "${ANSI_HEX[7]}"
    printf '\n[colors.bright]\n'
    printf 'black = "%s"\n' "${ANSI_HEX[8]}"
    printf 'red = "%s"\n' "${ANSI_HEX[9]}"
    printf 'green = "%s"\n' "${ANSI_HEX[10]}"
    printf 'yellow = "%s"\n' "${ANSI_HEX[11]}"
    printf 'blue = "%s"\n' "${ANSI_HEX[12]}"
    printf 'magenta = "%s"\n' "${ANSI_HEX[13]}"
    printf 'cyan = "%s"\n' "${ANSI_HEX[14]}"
    printf 'white = "%s"\n' "${ANSI_HEX[15]}"
  } >"$out_file"
}

fonts_requested() {
  if [[ -n "$CFG_fonts_tty" || -n "$CFG_fonts_terminal" || -n "$CFG_fonts_terminal_fallback" || -n "$CFG_fonts_ui" ]]; then
    return 0
  fi
  if [[ "$CFG_fontaa_antialias" != "default" || "$CFG_fontaa_subpixel" != "default" ]]; then
    return 0
  fi
  return 1
}

render_fontconfig() {
  local out_file="$1"
  local line aa_block subpixel_block mono_block ui_block fallback_block fallback_item
  local aa_value subpixel_value fallback_csv
  local esc_terminal esc_ui esc_item
  local -a fallback_list=()

  case "$CFG_fontaa_antialias" in
    on)
      aa_value='true'
      aa_block='<match target="font"><edit name="antialias" mode="assign"><bool>true</bool></edit></match>'
      ;;
    off)
      aa_value='false'
      aa_block='<match target="font"><edit name="antialias" mode="assign"><bool>false</bool></edit></match>'
      ;;
    *)
      aa_value='default'
      aa_block='<!-- antialias: default (fontconfig/system setting) -->'
      ;;
  esac

  case "$CFG_fontaa_subpixel" in
    rgb | bgr | none)
      subpixel_value="$CFG_fontaa_subpixel"
      subpixel_block="<match target=\"font\"><edit name=\"rgba\" mode=\"assign\"><const>${subpixel_value}</const></edit></match>"
      ;;
    *)
      subpixel_value='default'
      subpixel_block='<!-- subpixel: default (fontconfig/system setting) -->'
      ;;
  esac

  if [[ -n "$CFG_fonts_terminal" ]]; then
    esc_terminal="$(xml_escape "$CFG_fonts_terminal")"
    mono_block="<match target=\"pattern\"><test qual=\"any\" name=\"family\"><string>monospace</string></test><edit name=\"family\" mode=\"prepend\"><string>${esc_terminal}</string></edit></match>"
  else
    mono_block='<!-- terminal monospace family: default -->'
  fi

  if [[ -n "$CFG_fonts_ui" ]]; then
    esc_ui="$(xml_escape "$CFG_fonts_ui")"
    ui_block="<match target=\"pattern\"><test qual=\"any\" name=\"family\"><string>sans-serif</string></test><edit name=\"family\" mode=\"prepend\"><string>${esc_ui}</string></edit></match>"
  else
    ui_block='<!-- ui family: default -->'
  fi

  fallback_block=''
  fallback_csv="${CFG_fonts_terminal_fallback:-}"
  if [[ -n "$fallback_csv" ]]; then
    IFS=',' read -r -a fallback_list <<<"$fallback_csv"
    fallback_block='<match target="pattern"><test qual="any" name="family"><string>monospace</string></test>'
    for fallback_item in "${fallback_list[@]}"; do
      fallback_item="$(trim "$fallback_item")"
      [[ -z "$fallback_item" ]] && continue
      esc_item="$(xml_escape "$fallback_item")"
      fallback_block+="<edit name=\"family\" mode=\"append\"><string>${esc_item}</string></edit>"
    done
    fallback_block+='</match>'
  else
    fallback_block='<!-- terminal fallback list: none -->'
  fi

  : >"$out_file"
  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line//@AA_MODE@/$aa_value}"
    line="${line//@SUBPIXEL_MODE@/$subpixel_value}"
    line="${line//@AA_BLOCK@/$aa_block}"
    line="${line//@SUBPIXEL_BLOCK@/$subpixel_block}"
    line="${line//@MONOSPACE_BLOCK@/$mono_block}"
    line="${line//@UI_BLOCK@/$ui_block}"
    line="${line//@FALLBACK_BLOCK@/$fallback_block}"
    printf '%s\n' "$line" >>"$out_file"
  done <"$TEMPLATES_DIR/fontconfig.conf.in"
}

render_color_artifacts() {
  local stage_dir="$1"

  build_ansi_palette
  write_semantic_env "$stage_dir/semantic.env"
  write_semantic_env "$stage_dir/tty-palette.env"
  write_tty_palette_text "$stage_dir/tty-palette.txt"
  render_xresources "$stage_dir/xresources"
  cp "$stage_dir/xresources" "$stage_dir/Xresources"
  render_alacritty "$stage_dir/alacritty.toml"

  if fonts_requested; then
    render_fontconfig "$stage_dir/fontconfig.conf"
  else
    rm -f "$stage_dir/fontconfig.conf"
  fi
}

declare -a CUSTOM_PALETTE_LINES=()

load_custom_palette() {
  local path="$1"
  local wanted="$2"
  local line parsed hex r g b
  local lr lg lb

  CUSTOM_PALETTE_LINES=()

  [[ -f "$path" ]] || die "custom palette file not found: $path"

  if ((wanted > 32)); then
    die "custom palettes support at most 32 colors"
  fi

  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line%$'\r'}"
    line="$(trim "$line")"
    [[ -z "$line" ]] && continue

    # "# " prefix denotes a comment line in custom palette files.
    if [[ "$line" == "# "* ]]; then
      continue
    fi

    if [[ "$line" =~ ^#([A-Fa-f0-9]{6})$ ]]; then
      hex="${BASH_REMATCH[1]}"
      r=$((16#${hex:0:2}))
      g=$((16#${hex:2:2}))
      b=$((16#${hex:4:2}))
      parsed="$(normalize_rgb_triplet "$r,$g,$b")" || die "invalid custom color '$line' in $path"
    elif [[ "$line" == *","*","* ]]; then
      parsed="$(normalize_rgb_triplet "$line")" || die "invalid custom color '$line' in $path"
    elif [[ "$line" =~ ^[0-9.]+[[:space:]]+[0-9.]+[[:space:]]+[0-9.]+$ ]]; then
      parsed="$(normalize_rgb_triplet "${line//[[:space:]]/,}")" || die "invalid custom color '$line' in $path"
    else
      die "invalid custom color '$line' in $path (expected #RRGGBB or r,g,b)"
    fi

    IFS=',' read -r r g b <<<"$parsed"
    lr="$(srgb_component_to_linear "$r")"
    lg="$(srgb_component_to_linear "$g")"
    lb="$(srgb_component_to_linear "$b")"
    CUSTOM_PALETTE_LINES+=("    vec3(${lr}, ${lg}, ${lb})")

    if ((${#CUSTOM_PALETTE_LINES[@]} == wanted)); then
      break
    fi
  done <"$path"

  if ((${#CUSTOM_PALETTE_LINES[@]} < wanted)); then
    die "custom palette file '$path' has ${#CUSTOM_PALETTE_LINES[@]} colors, expected at least $wanted"
  fi
}

render_shader() {
  local out_file="$1"
  local mode_passthrough=0 mode_mono=0 mode_palette=0
  local hotcore=0 enable_dither=0 enable_scanlines=0 enable_flicker=0 enable_vignette=0
  local palette_kind_vga16=0
  local palette_kind_mono2=0 palette_kind_mono4=0 palette_kind_mono8=0 palette_kind_mono16=0
  local palette_kind_cube32=0 palette_kind_cube64=0 palette_kind_cube128=0 palette_kind_cube256=0
  local palette_kind_custom=0
  local mono_bands=2 palette_size=16 custom_palette_size=1
  local custom_block_file line

  case "$CFG_mode_type" in
    passthrough)
      mode_passthrough=1
      ;;
    monochrome)
      mode_mono=1
      ;;
    palette)
      mode_palette=1
      ;;
  esac

  [[ "$CFG_monochrome_hotcore" == "true" ]] && hotcore=1
  [[ "$CFG_effects_dither" == "ordered" ]] && enable_dither=1
  [[ "$CFG_effects_scanlines" == "true" ]] && enable_scanlines=1
  [[ "$CFG_effects_flicker" == "true" ]] && enable_flicker=1
  [[ "$CFG_effects_vignette" == "true" ]] && enable_vignette=1

  case "$CFG_palette_kind" in
    vga16)
      palette_kind_vga16=1
      ;;
    mono2)
      palette_kind_mono2=1
      ;;
    mono4)
      palette_kind_mono4=1
      ;;
    mono8)
      palette_kind_mono8=1
      ;;
    mono16)
      palette_kind_mono16=1
      ;;
    cube32)
      palette_kind_cube32=1
      ;;
    cube64)
      palette_kind_cube64=1
      ;;
    cube128)
      palette_kind_cube128=1
      ;;
    cube256)
      palette_kind_cube256=1
      ;;
    custom)
      palette_kind_custom=1
      ;;
  esac

  mono_bands="$CFG_monochrome_bands"
  if ((mono_bands < 2)); then
    mono_bands=2
  elif ((mono_bands > 256)); then
    mono_bands=256
  fi

  palette_size="$CFG_palette_size"
  if ((palette_size < 2)); then
    palette_size=2
  elif ((palette_size > 256)); then
    palette_size=256
  fi

  custom_block_file="$(mktemp "$STATE_DIR/custom_palette_block.XXXXXX")"

  if [[ "$CFG_mode_type" == "palette" && "$CFG_palette_kind" == "custom" ]]; then
    local custom_path
    custom_path="$(resolve_custom_palette_path)" || die "unable to resolve custom palette file path"
    load_custom_palette "$custom_path" "$palette_size"
    custom_palette_size="$palette_size"
  else
    CUSTOM_PALETTE_LINES=("    vec3(1.000000, 1.000000, 1.000000)")
    custom_palette_size=1
  fi

  {
    printf 'const vec3 CUSTOM_PALETTE[CUSTOM_PALETTE_SIZE] = vec3[](\n'
    local i
    for ((i = 0; i < ${#CUSTOM_PALETTE_LINES[@]}; i++)); do
      if ((i == ${#CUSTOM_PALETTE_LINES[@]} - 1)); then
        printf '%s\n' "${CUSTOM_PALETTE_LINES[$i]}"
      else
        printf '%s,\n' "${CUSTOM_PALETTE_LINES[$i]}"
      fi
    done
    printf ');\n'
  } >"$custom_block_file"

  : >"$out_file"
  while IFS= read -r line || [[ -n "$line" ]]; do
    if [[ "$line" == "@CUSTOM_PALETTE_BLOCK@" ]]; then
      cat "$custom_block_file" >>"$out_file"
      continue
    fi

    line="${line//@MODE_PASSTHROUGH@/$mode_passthrough}"
    line="${line//@MODE_MONO@/$mode_mono}"
    line="${line//@MODE_PALETTE@/$mode_palette}"

    line="${line//@MONO_BANDS@/$mono_bands}"
    line="${line//@PHOSPHOR_R@/$CFG_phosphor_r}"
    line="${line//@PHOSPHOR_G@/$CFG_phosphor_g}"
    line="${line//@PHOSPHOR_B@/$CFG_phosphor_b}"
    line="${line//@HOTCORE@/$hotcore}"

    line="${line//@ENABLE_DITHER@/$enable_dither}"
    line="${line//@ENABLE_SCANLINES@/$enable_scanlines}"
    line="${line//@ENABLE_FLICKER@/$enable_flicker}"
    line="${line//@ENABLE_VIGNETTE@/$enable_vignette}"
    line="${line//@SCANLINE_BASE@/$CFG_scanline_base}"
    line="${line//@SCANLINE_AMP@/$CFG_scanline_amp}"

    line="${line//@PALETTE_KIND_VGA16@/$palette_kind_vga16}"
    line="${line//@PALETTE_KIND_MONO2@/$palette_kind_mono2}"
    line="${line//@PALETTE_KIND_MONO4@/$palette_kind_mono4}"
    line="${line//@PALETTE_KIND_MONO8@/$palette_kind_mono8}"
    line="${line//@PALETTE_KIND_MONO16@/$palette_kind_mono16}"
    line="${line//@PALETTE_KIND_CUBE32@/$palette_kind_cube32}"
    line="${line//@PALETTE_KIND_CUBE64@/$palette_kind_cube64}"
    line="${line//@PALETTE_KIND_CUBE128@/$palette_kind_cube128}"
    line="${line//@PALETTE_KIND_CUBE256@/$palette_kind_cube256}"
    line="${line//@PALETTE_KIND_CUSTOM@/$palette_kind_custom}"
    line="${line//@PALETTE_SIZE@/$palette_size}"
    line="${line//@CUSTOM_PALETTE_SIZE@/$custom_palette_size}"
    line="${line//@BG_TINT_LINEAR_R@/$CFG_bg_tint_linear_r}"
    line="${line//@BG_TINT_LINEAR_G@/$CFG_bg_tint_linear_g}"
    line="${line//@BG_TINT_LINEAR_B@/$CFG_bg_tint_linear_b}"

    printf '%s\n' "$line" >>"$out_file"
  done <"$TEMPLATES_DIR/shader.glsl.in"

  rm -f "$custom_block_file"
}

render_picom() {
  local out_file="$1"
  local blur_enabled="false"
  local line
  local unredir_line="# unredir-if-possible left at picom default."
  local transparency_block=""
  local blur_exclude_block=""
  local rules_note=""
  local value safe
  local -a class_rules=()
  local -a name_rules=()
  local -a all_rules=()
  local -a class_items=()
  local -a name_items=()
  local idx

  if ((CFG_effects_blur_strength > 0)); then
    blur_enabled="true"
  fi

  if [[ -n "$CFG_rules_exclude_wm_class" ]]; then
    IFS=',' read -r -a class_items <<<"$CFG_rules_exclude_wm_class"
    for value in "${class_items[@]}"; do
      value="$(trim "$value")"
      [[ -z "$value" ]] && continue
      safe="${value//\'/}"
      class_rules+=("class_g = '$safe'")
    done
  fi

  if [[ -n "$CFG_rules_exclude_wm_name" ]]; then
    IFS=',' read -r -a name_items <<<"$CFG_rules_exclude_wm_name"
    for value in "${name_items[@]}"; do
      value="$(trim "$value")"
      [[ -z "$value" ]] && continue
      safe="${value//\'/}"
      name_rules+=("name = '$safe'")
    done
  fi

  all_rules=("${class_rules[@]}" "${name_rules[@]}")
  if [[ -n "$CFG_rules_exclude_opacity_below" ]]; then
    all_rules+=("opacity < $CFG_rules_exclude_opacity_below")
  fi

  if ((${#all_rules[@]} > 0)); then
    blur_exclude_block=$'blur-background-exclude = [\n'
    for ((idx = 0; idx < ${#all_rules[@]}; idx++)); do
      if ((idx == ${#all_rules[@]} - 1)); then
        blur_exclude_block+="  \"${all_rules[$idx]}\"\n"
      else
        blur_exclude_block+="  \"${all_rules[$idx]}\",\n"
      fi
    done
    blur_exclude_block+=$'];'
    rules_note="# Exclusion rules apply to blur; picom shader exclusion granularity is limited."
    unredir_line="unredir-if-possible = false;"
  else
    blur_exclude_block="# No blur exclusion rules requested."
  fi

  case "$CFG_effects_transparency" in
    off)
      transparency_block=$'detect-client-opacity = false;\ninactive-opacity = 1.0;\nactive-opacity = 1.0;\nframe-opacity = 1.0;'
      ;;
    on)
      transparency_block='detect-client-opacity = true;'
      ;;
    rules)
      transparency_block='detect-client-opacity = true;'
      unredir_line="unredir-if-possible = false;"
      ;;
    *)
      transparency_block='detect-client-opacity = false;'
      ;;
  esac

  : >"$out_file"
  while IFS= read -r line || [[ -n "$line" ]]; do
    line="${line//@BLUR_STRENGTH@/$CFG_effects_blur_strength}"
    line="${line//@BLUR_ENABLED@/$blur_enabled}"
    line="${line//@SHADER_PATH@/shader.glsl}"
    line="${line//@UNREDIR_LINE@/$unredir_line}"
    line="${line//@TRANSPARENCY_BLOCK@/$transparency_block}"
    line="${line//@BLUR_EXCLUDE_BLOCK@/$blur_exclude_block}"
    line="${line//@RULES_NOTE@/$rules_note}"
    printf '%s\n' "$line" >>"$out_file"
  done <"$TEMPLATES_DIR/picom.conf.in"
}

render_templates() {
  local stage_dir="$1"
  local profile_path="$2"
  local session_type="${3:-x11}"

  cp "$profile_path" "$stage_dir/profile.toml"
  write_profile_env "$stage_dir/profile.env"

  if [[ "$session_type" == "wayland" ]]; then
    rm -f "$stage_dir/shader.glsl" "$stage_dir/picom.conf"
  else
    render_shader "$stage_dir/shader.glsl"
    render_picom "$stage_dir/picom.conf"
  fi

  render_color_artifacts "$stage_dir"

  {
    printf 'generated_at=%s\n' "$(now_ts)"
    printf 'profile=%s\n' "$(basename "$profile_path")"
    printf 'session_type=%s\n' "$session_type"
  } >"$stage_dir/meta"
}

validate_generated_shader() {
  local stage_dir="$1"
  local shader_file="$stage_dir/shader.glsl"
  local placeholders open_braces close_braces custom_size
  local -a steps=(
    "PIPELINE_STEP_1_LINEARIZE"
    "PIPELINE_STEP_2_TRANSFORM"
    "PIPELINE_STEP_3_QUANTIZE"
    "PIPELINE_STEP_4_DITHER"
    "PIPELINE_STEP_5_SCANLINES"
    "PIPELINE_STEP_6_FLICKER"
    "PIPELINE_STEP_7_VIGNETTE"
    "PIPELINE_STEP_8_ENCODE"
  )
  local marker line prev=0

  [[ -f "$shader_file" ]] || {
    warn "shader validation failed: missing $shader_file"
    return 1
  }

  placeholders="$(grep -En '@[A-Z0-9_]+@' "$shader_file" || true)"
  if [[ -n "$placeholders" ]]; then
    warn "shader validation failed: unsubstituted placeholders found"
    printf '%s\n' "$placeholders" >&2
    return 1
  fi

  grep -q 'void main()' "$shader_file" || {
    warn "shader validation failed: missing main()"
    return 1
  }

  grep -q 'gl_FragColor' "$shader_file" || {
    warn "shader validation failed: missing gl_FragColor write"
    return 1
  }

  grep -q 'for (i = 0; i < 16; i++)' "$shader_file" || {
    warn "shader validation failed: VGA16 loop bound missing or modified"
    return 1
  }

  if grep -Fq 'for (i = 0; i < 256' "$shader_file"; then
    warn "shader validation failed: forbidden 256-iteration loop detected"
    return 1
  fi

  custom_size="$(grep '^#define CUSTOM_PALETTE_SIZE ' "$shader_file" | awk '{print $3}' | head -n1 || true)"
  if [[ -n "$custom_size" && "$custom_size" =~ ^[0-9]+$ ]]; then
    if ((custom_size > 32)); then
      warn "shader validation failed: custom palette size exceeds 32 ($custom_size)"
      return 1
    fi
  fi

  for marker in "${steps[@]}"; do
    line="$(grep -n "$marker" "$shader_file" | head -n1 | cut -d: -f1)"
    if [[ -z "$line" ]]; then
      warn "shader validation failed: missing marker $marker"
      return 1
    fi
    if ((line <= prev)); then
      warn "shader validation failed: marker order is invalid at $marker"
      return 1
    fi
    prev="$line"
  done

  open_braces="$(tr -cd '{' <"$shader_file" | wc -c | awk '{print $1}')"
  close_braces="$(tr -cd '}' <"$shader_file" | wc -c | awk '{print $1}')"
  if [[ "$open_braces" != "$close_braces" ]]; then
    warn "shader validation failed: brace count mismatch ($open_braces vs $close_braces)"
    return 1
  fi

  return 0
}

validate_stage_outputs() {
  local stage_dir="$1"
  local session_type="${2:-x11}"

  [[ -f "$stage_dir/profile.toml" ]] || return 1
  [[ -f "$stage_dir/profile.env" ]] || return 1
  [[ -f "$stage_dir/xresources" ]] || return 1
  [[ -f "$stage_dir/Xresources" ]] || return 1
  [[ -f "$stage_dir/alacritty.toml" ]] || return 1
  [[ -f "$stage_dir/semantic.env" ]] || return 1
  [[ -f "$stage_dir/tty-palette.env" ]] || return 1
  [[ -f "$stage_dir/tty-palette.txt" ]] || return 1
  [[ -f "$stage_dir/meta" ]] || return 1

  if fonts_requested; then
    [[ -f "$stage_dir/fontconfig.conf" ]] || return 1
  fi

  if [[ "$session_type" == "wayland" ]]; then
    if [[ -f "$stage_dir/picom.conf" || -f "$stage_dir/shader.glsl" ]]; then
      warn "wayland stage should not contain picom/shader targets"
      return 1
    fi
    return 0
  fi

  [[ -f "$stage_dir/picom.conf" ]] || return 1
  [[ -f "$stage_dir/shader.glsl" ]] || return 1
  validate_generated_shader "$stage_dir"
}

validate_stage_with_picom() {
  local stage_dir="$1"
  local session_type="${2:-x11}"
  local log_file="$stage_dir/picom-validate.log"
  local rc=0

  if ! validate_stage_outputs "$stage_dir" "$session_type"; then
    warn "generated stage validation failed"
    return 1
  fi

  if [[ "$session_type" == "wayland" ]]; then
    return 0
  fi

  if ! command -v picom >/dev/null 2>&1; then
    warn "picom not installed; skipping runtime shader validation"
    return 0
  fi

  if ! detect_x11; then
    warn "DISPLAY is not set; skipping runtime shader validation"
    return 0
  fi

  if command -v pgrep >/dev/null 2>&1 && pgrep -x picom >/dev/null 2>&1; then
    warn "picom is already running; skipping test instance validation"
    return 0
  fi

  if command -v timeout >/dev/null 2>&1; then
    (cd "$stage_dir" && timeout 3s picom --config picom.conf --log-file "$log_file" >/dev/null 2>&1) || rc=$?
  else
    (cd "$stage_dir" && picom --config picom.conf --log-file "$log_file" >/dev/null 2>&1) || rc=$?
  fi

  if [[ "$rc" -ne 0 && "$rc" -ne 124 ]]; then
    if [[ -f "$log_file" ]] && grep -Eiq 'another composite manager' "$log_file"; then
      warn "another compositor is active; skipping validation"
      return 0
    fi
    warn "picom validation failed with exit code $rc"
    [[ -f "$log_file" ]] && sed -n '1,40p' "$log_file" >&2
    return 1
  fi

  if [[ -f "$log_file" ]] && grep -Eiq '(shader.*(fail|error)|compile error|error:)' "$log_file"; then
    if grep -Eiq 'another composite manager' "$log_file"; then
      warn "another compositor is active; skipping validation"
      return 0
    fi
    warn "picom reported shader or config errors during validation"
    sed -n '1,40p' "$log_file" >&2
    return 1
  fi

  return 0
}

backup_active() {
  local profile_id="$1"
  local ts backup_name backup_dir

  ensure_dirs
  ts="$(now_ts_compact)"
  backup_name="${ts}-${profile_id//[^A-Za-z0-9._-]/_}-pid$$"
  backup_dir="$BACKUPS_DIR/$backup_name"
  mkdir -p "$backup_dir"

  if dir_has_files "$ACTIVE_DIR"; then
    cp -a "$ACTIVE_DIR"/. "$backup_dir"/
  fi
}

prune_backups() {
  local keep_count="${1:-$BACKUP_KEEP}"
  local -a entries=()
  local remove_count i

  [[ -d "$BACKUPS_DIR" ]] || return 0

  while IFS= read -r entry; do
    entries+=("$entry")
  done < <(find "$BACKUPS_DIR" -mindepth 1 -maxdepth 1 -type d -printf '%f\n' | sort)

  if ((${#entries[@]} <= keep_count)); then
    return 0
  fi

  remove_count=$((${#entries[@]} - keep_count))
  for ((i = 0; i < remove_count; i++)); do
    rm -rf "$BACKUPS_DIR/${entries[$i]}"
  done
}

atomic_swap_active() {
  local stage_dir="$1"
  local old_active

  old_active="$STATE_DIR/active.prev.$$.${RANDOM}"
  rm -rf "$old_active"

  if [[ -d "$ACTIVE_DIR" ]]; then
    mv "$ACTIVE_DIR" "$old_active"
  else
    mkdir -p "$old_active"
  fi

  if mv "$stage_dir" "$ACTIVE_DIR"; then
    rm -rf "$old_active"
    return 0
  fi

  warn "active swap failed; rolling back"
  rm -rf "$ACTIVE_DIR"
  if [[ -d "$old_active" ]]; then
    mv "$old_active" "$ACTIVE_DIR"
  fi
  return 1
}

copy_active_to_last_good() {
  local staging old

  ensure_dirs
  staging="$(mktemp -d "$STATE_DIR/last_good.new.$(now_ts_compact).$$.XXXXXX")"

  if dir_has_files "$ACTIVE_DIR"; then
    cp -a "$ACTIVE_DIR"/. "$staging"/
  fi

  old="$STATE_DIR/last_good.old.$$.${RANDOM}"
  rm -rf "$old"

  if [[ -d "$LAST_GOOD_DIR" ]]; then
    mv "$LAST_GOOD_DIR" "$old"
  fi

  mv "$staging" "$LAST_GOOD_DIR"
  rm -rf "$old"
}

restore_last_good() {
  local restore_dir old_active

  if ! dir_has_files "$LAST_GOOD_DIR"; then
    warn "last_good is not available for rollback"
    return 1
  fi

  warn "restoring active/ from last_good"
  restore_dir="$(mktemp -d "$STATE_DIR/restore.$(now_ts_compact).$$.XXXXXX")"
  cp -a "$LAST_GOOD_DIR"/. "$restore_dir"/

  old_active="$STATE_DIR/active.bad.$$.${RANDOM}"
  rm -rf "$old_active"
  if [[ -d "$ACTIVE_DIR" ]]; then
    mv "$ACTIVE_DIR" "$old_active"
  fi

  if mv "$restore_dir" "$ACTIVE_DIR"; then
    rm -rf "$old_active"
    return 0
  fi

  rm -rf "$restore_dir"
  if [[ -d "$old_active" ]]; then
    mv "$old_active" "$ACTIVE_DIR"
  fi
  return 1
}

restore_last_good_if_needed() {
  if dir_has_files "$ACTIVE_DIR"; then
    return 0
  fi
  restore_last_good || true
}

apply_scoped_backends() {
  local session_type="${1:-x11}"

  if [[ "$CFG_scope_x11" == "true" ]]; then
    if [[ "$session_type" == "wayland" ]]; then
      info "wayland session detected: skipping x11 compositor backend"
    elif [[ -x "$BACKEND_X11" ]]; then
      "$BACKEND_X11" apply "$ACTIVE_DIR" || warn "x11 backend apply hook reported an issue"
    fi
  fi

  if [[ "$CFG_scope_tty" == "true" && -x "$BACKEND_TTY" ]]; then
    if ! "$BACKEND_TTY" apply "$ACTIVE_DIR"; then
      LAST_ERROR="tty backend apply failed"
      return 1
    fi
  fi

  if [[ "$CFG_scope_tuigreet" == "true" && -x "$BACKEND_TUIGREET" ]]; then
    "$BACKEND_TUIGREET" apply "$ACTIVE_DIR" || warn "tuigreet backend apply hook reported an issue"
  fi

  return 0
}

restart_picom_if_running() {
  # Disabled by default to avoid changing runtime behavior unexpectedly.
  if [[ "${RETROFX_RELOAD_PICOM:-0}" != "1" ]]; then
    return 0
  fi

  if ! detect_x11 || ! command -v pgrep >/dev/null 2>&1; then
    return 0
  fi

  if ! pgrep -x picom >/dev/null 2>&1; then
    return 0
  fi

  if command -v pkill >/dev/null 2>&1; then
    pkill -HUP -x picom >/dev/null 2>&1 || warn "failed to signal running picom"
    return 0
  fi

  local pid
  while IFS= read -r pid; do
    kill -HUP "$pid" >/dev/null 2>&1 || warn "failed to signal picom pid=$pid"
  done < <(pgrep -x picom || true)
}

create_builtin_passthrough_profile() {
  local out_file="$1"
  cat >"$out_file" <<'PROFILE'
name = "Passthrough"
version = 1

[mode]
type = "passthrough"

[effects]
blur_strength = 0
scanlines = false
flicker = false
dither = "none"
vignette = false

[scope]
x11 = true
tty = false
tuigreet = false
PROFILE
}

list_profiles() {
  local current_profile=""
  local current_path=""
  local found=0
  local profile base

  if [[ -f "$ACTIVE_DIR/profile.env" ]]; then
    # shellcheck source=/dev/null
    source "$ACTIVE_DIR/profile.env"
    current_profile="${PROFILE_ID:-}"
    current_path="${PROFILE_PATH:-}"
  fi

  print_profile_group() {
    local title="$1"
    local dir="$2"
    local maxdepth="${3:-1}"
    local group_found=0
    local path

    [[ -d "$dir" ]] || return 0

    while IFS= read -r path; do
      [[ -e "$path" ]] || continue
      if [[ "$group_found" -eq 0 ]]; then
        printf '%s:\n' "$title"
      fi
      group_found=1
      found=1
      base="$(basename "$path")"
      base="${base%.toml}"
      if [[ "$path" == "$current_path" || "$base" == "$current_profile" ]]; then
        printf '  %s (active)\n' "$base"
      else
        printf '  %s\n' "$base"
      fi
    done < <(find "$dir" -mindepth 1 -maxdepth "$maxdepth" -type f -name '*.toml' | sort)

    if [[ "$group_found" -eq 1 ]]; then
      printf '\n'
    fi
  }

  print_profile_group "Core Pack" "$PROFILES_PACKS_DIR/core" 1

  if [[ -d "$PROFILES_PACKS_DIR" ]]; then
    local pack_dir pack_name
    while IFS= read -r pack_dir; do
      pack_name="$(basename "$pack_dir")"
      [[ "$pack_name" == "core" ]] && continue
      print_profile_group "Pack $pack_name" "$pack_dir" 1
    done < <(find "$PROFILES_PACKS_DIR" -mindepth 1 -maxdepth 1 -type d | sort)
  fi

  print_profile_group "User Profiles" "$PROFILES_USER_DIR" 1
  print_profile_group "Profiles" "$PROFILES_DIR" 1

  if [[ "$found" -eq 0 ]]; then
    printf 'no profiles found under %s\n' "$PROFILES_DIR"
  fi
}

profile_origin_label() {
  local path="$1"
  local rel pack_name

  if [[ "$path" == "$PROFILES_USER_DIR/"* ]]; then
    printf 'user'
    return 0
  fi

  if [[ "$path" == "$PROFILES_PACKS_DIR/"* ]]; then
    rel="${path#"$PROFILES_PACKS_DIR"/}"
    pack_name="${rel%%/*}"
    printf 'pack/%s' "$pack_name"
    return 0
  fi

  printf 'profiles'
}

format_tags_csv() {
  local tags="$1"
  printf '%s' "${tags//,/, }"
}

iter_all_profile_paths() {
  if [[ -d "$PROFILES_USER_DIR" ]]; then
    find "$PROFILES_USER_DIR" -mindepth 1 -maxdepth 1 -type f -name '*.toml' | sort
  fi
  if [[ -d "$PROFILES_PACKS_DIR" ]]; then
    find "$PROFILES_PACKS_DIR" -type f -name '*.toml' | sort
  fi
  find "$PROFILES_DIR" -mindepth 1 -maxdepth 1 -type f -name '*.toml' | sort
}

cmd_list() {
  list_profiles
}

cmd_search() {
  local keyword="$1"
  local needle path profile_id origin hay base
  local found=0

  needle="$(printf '%s' "$keyword" | tr '[:upper:]' '[:lower:]')"

  while IFS= read -r path; do
    [[ -f "$path" ]] || continue
    base="$(basename "$path")"
    profile_id="${base%.toml}"
    parse_profile "$path"
    hay="$(printf '%s %s %s %s %s %s' \
      "$profile_id" "$CFG_name" "$CFG_description" "$CFG_tags" "$CFG_author" "$CFG_license" | tr '[:upper:]' '[:lower:]')"
    if [[ "$hay" == *"$needle"* ]]; then
      found=1
      origin="$(profile_origin_label "$path")"
      if [[ -n "$CFG_description" ]]; then
        printf '%s [%s] - %s\n' "$profile_id" "$origin" "$CFG_description"
      else
        printf '%s [%s]\n' "$profile_id" "$origin"
      fi
    fi
  done < <(iter_all_profile_paths)

  if [[ "$found" -eq 0 ]]; then
    printf 'no profiles matched: %s\n' "$keyword"
  fi
}

cmd_info() {
  local profile_ref="$1"
  local profile_path profile_id origin

  profile_path="$(resolve_profile_path "$profile_ref")" || die "profile not found: $profile_ref"
  profile_id="$(basename "$profile_path")"
  profile_id="${profile_id%.toml}"
  origin="$(profile_origin_label "$profile_path")"

  load_profile "$profile_path"

  printf 'Profile: %s\n' "$profile_id"
  printf 'Path: %s\n' "$profile_path"
  printf 'Origin: %s\n' "$origin"
  printf 'Name: %s\n' "$CFG_name"
  printf 'Version: %s\n' "$CFG_version"
  if [[ -n "$CFG_description" ]]; then
    printf 'Description: %s\n' "$CFG_description"
  fi
  if [[ -n "$CFG_tags" ]]; then
    printf 'Tags: %s\n' "$(format_tags_csv "$CFG_tags")"
  fi
  if [[ -n "$CFG_author" ]]; then
    printf 'Author: %s\n' "$CFG_author"
  fi
  if [[ -n "$CFG_license" ]]; then
    printf 'License: %s\n' "$CFG_license"
  fi

  printf '\nMode\n'
  printf '  type = %s\n' "$CFG_mode_type"
  case "$CFG_mode_type" in
    monochrome)
      printf '  bands = %s\n' "$CFG_monochrome_bands"
      printf '  phosphor = %s\n' "$CFG_monochrome_phosphor"
      if [[ "$CFG_monochrome_phosphor" == "custom" ]]; then
        printf '  custom_rgb = %s\n' "$CFG_monochrome_custom_rgb"
      fi
      printf '  hotcore = %s\n' "$CFG_monochrome_hotcore"
      ;;
    palette)
      printf '  kind = %s\n' "$CFG_palette_kind"
      printf '  size = %s\n' "$CFG_palette_size"
      if [[ "$CFG_palette_kind" == "custom" ]]; then
        printf '  custom_file = %s\n' "$CFG_palette_custom_file"
      fi
      ;;
  esac

  printf '\nEffects\n'
  printf '  blur_strength = %s\n' "$CFG_effects_blur_strength"
  printf '  scanlines = %s\n' "$CFG_effects_scanlines"
  printf '  flicker = %s\n' "$CFG_effects_flicker"
  printf '  dither = %s\n' "$CFG_effects_dither"
  printf '  vignette = %s\n' "$CFG_effects_vignette"
  if [[ -n "$CFG_effects_scanline_preset" ]]; then
    printf '  scanline_preset = %s\n' "$CFG_effects_scanline_preset"
  fi
  printf '  transparency = %s\n' "$CFG_effects_transparency"

  if [[ -n "$CFG_colors_background" || -n "$CFG_colors_foreground" ]]; then
    printf '\nColors\n'
    if [[ -n "$CFG_colors_background" ]]; then
      printf '  background = %s\n' "$CFG_colors_background"
    fi
    if [[ -n "$CFG_colors_foreground" ]]; then
      printf '  foreground = %s\n' "$CFG_colors_foreground"
    fi
  fi

  if [[ -n "$CFG_rules_exclude_wm_class" || -n "$CFG_rules_exclude_wm_name" || -n "$CFG_rules_exclude_opacity_below" ]]; then
    printf '\nRules\n'
    if [[ -n "$CFG_rules_exclude_wm_class" ]]; then
      printf '  exclude_wm_class = %s\n' "$(format_tags_csv "$CFG_rules_exclude_wm_class")"
    fi
    if [[ -n "$CFG_rules_exclude_wm_name" ]]; then
      printf '  exclude_wm_name = %s\n' "$(format_tags_csv "$CFG_rules_exclude_wm_name")"
    fi
    if [[ -n "$CFG_rules_exclude_opacity_below" ]]; then
      printf '  exclude_opacity_below = %s\n' "$CFG_rules_exclude_opacity_below"
    fi
  fi

  if [[ -n "$CFG_fonts_tty" || -n "$CFG_fonts_terminal" || -n "$CFG_fonts_terminal_fallback" || -n "$CFG_fonts_ui" ]]; then
    printf '\nFonts\n'
    if [[ -n "$CFG_fonts_tty" ]]; then
      printf '  tty = %s\n' "$CFG_fonts_tty"
    fi
    if [[ -n "$CFG_fonts_terminal" ]]; then
      printf '  terminal = %s\n' "$CFG_fonts_terminal"
    fi
    if [[ -n "$CFG_fonts_terminal_fallback" ]]; then
      printf '  terminal_fallback = %s\n' "$(format_tags_csv "$CFG_fonts_terminal_fallback")"
    fi
    if [[ -n "$CFG_fonts_ui" ]]; then
      printf '  ui = %s\n' "$CFG_fonts_ui"
    fi
  fi

  if [[ "$CFG_fontaa_antialias" != "default" || "$CFG_fontaa_subpixel" != "default" ]]; then
    printf '\nFont AA\n'
    printf '  antialias = %s\n' "$CFG_fontaa_antialias"
    printf '  subpixel = %s\n' "$CFG_fontaa_subpixel"
  fi

  printf '\nScope\n'
  printf '  x11 = %s\n' "$CFG_scope_x11"
  printf '  tty = %s\n' "$CFG_scope_tty"
  printf '  tuigreet = %s\n' "$CFG_scope_tuigreet"
}

json_escape_string() {
  local value="$1"
  value="${value//\\/\\\\}"
  value="${value//\"/\\\"}"
  value="${value//$'\n'/ }"
  value="${value//$'\r'/ }"
  value="${value//$'\t'/ }"
  printf '%s' "$value"
}

declare -a BASE16_COLORS=()
declare BASE16_META_SCHEME=""
declare BASE16_META_AUTHOR=""

load_base16_json_colors() {
  local scheme_path="$1"
  local parsed_file key value idx

  command -v python3 >/dev/null 2>&1 || die "python3 is required for base16 JSON import"
  [[ -f "$scheme_path" ]] || die "base16 file not found: $scheme_path"

  parsed_file="$(mktemp "$STATE_DIR/base16-parse.XXXXXX")"
  if ! python3 - "$scheme_path" >"$parsed_file" <<'PY'
import json
import re
import sys

path = sys.argv[1]
try:
    with open(path, "r", encoding="utf-8") as fh:
        data = json.load(fh)
except Exception as exc:
    print(f"base16 parse error: invalid JSON ({exc})", file=sys.stderr)
    sys.exit(1)

if not isinstance(data, dict):
    print("base16 parse error: root must be a JSON object", file=sys.stderr)
    sys.exit(1)

norm = {}
for key, value in data.items():
    if isinstance(key, str):
        norm[key.lower()] = value

required = [f"base{i:02x}" for i in range(16)]
for key in required:
    if key not in norm:
        print(f"base16 parse error: missing required key '{key}'", file=sys.stderr)
        sys.exit(1)
    value = norm[key]
    if not isinstance(value, str):
        print(f"base16 parse error: key '{key}' must be a string", file=sys.stderr)
        sys.exit(1)
    text = value.strip()
    if text.startswith("#"):
        text = text[1:]
    elif text.lower().startswith("0x"):
        text = text[2:]
    if re.fullmatch(r"[0-9a-fA-F]{6}", text) is None:
        print(f"base16 parse error: key '{key}' must be #RRGGBB", file=sys.stderr)
        sys.exit(1)
    print(f"{key}\t#{text.lower()}")

for meta_key in ("scheme", "author"):
    value = norm.get(meta_key, "")
    if isinstance(value, str):
        text = value.replace("\n", " ").replace("\r", " ").strip()
        print(f"meta_{meta_key}\t{text}")
PY
  then
    rm -f "$parsed_file"
    return 1
  fi

  BASE16_COLORS=()
  for ((idx = 0; idx < 16; idx++)); do
    BASE16_COLORS[idx]=""
  done
  BASE16_META_SCHEME=""
  BASE16_META_AUTHOR=""

  while IFS=$'\t' read -r key value; do
    case "$key" in
      base[0-9a-f][0-9a-f])
        idx=$((16#${key#base}))
        BASE16_COLORS[$idx]="$value"
        ;;
      meta_scheme)
        BASE16_META_SCHEME="$value"
        ;;
      meta_author)
        BASE16_META_AUTHOR="$value"
        ;;
    esac
  done <"$parsed_file"
  rm -f "$parsed_file"

  for ((idx = 0; idx < 16; idx++)); do
    [[ -n "${BASE16_COLORS[$idx]}" ]] || die "base16 parse error: incomplete palette"
  done
}

cmd_import_base16() {
  local scheme_path=""
  local profile_name=""
  local scheme_basename=""
  local profile_slug=""
  local profile_path=""
  local palette_rel_path=""
  local palette_abs_path=""
  local tmp_profile=""
  local tmp_palette=""
  local i

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --name)
        [[ $# -ge 2 ]] || die "import base16: --name requires a value"
        profile_name="$2"
        shift 2
        ;;
      --*)
        die "import base16: unknown option '$1'"
        ;;
      *)
        if [[ -z "$scheme_path" ]]; then
          scheme_path="$1"
          shift
        else
          die "import base16: unexpected argument '$1'"
        fi
        ;;
    esac
  done

  [[ -n "$scheme_path" ]] || die "import base16 requires a path to a JSON file"
  [[ -n "$profile_name" ]] || die "import base16 requires --name <profile-name>"

  scheme_path="$(expand_user_path "$scheme_path")"
  [[ "$scheme_path" == /* ]] || scheme_path="$PWD/$scheme_path"
  scheme_path="${scheme_path%/}"
  scheme_basename="$(basename "$scheme_path")"

  case "$scheme_path" in
    *.yaml | *.yml)
      die "import base16 currently supports JSON only (YAML not supported in this build)"
      ;;
  esac

  load_base16_json_colors "$scheme_path"

  profile_slug="$(slugify_filename "$profile_name")"
  profile_path="$PROFILES_USER_DIR/$profile_slug.toml"
  palette_rel_path="../../palettes/imported/$profile_slug.txt"
  palette_abs_path="$ROOT_DIR/palettes/imported/$profile_slug.txt"

  mkdir -p "$PROFILES_USER_DIR" "$ROOT_DIR/palettes/imported"
  [[ ! -e "$profile_path" ]] || die "refusing to overwrite existing profile: $profile_path"
  [[ ! -e "$palette_abs_path" ]] || die "refusing to overwrite existing palette file: $palette_abs_path"

  tmp_palette="$(mktemp "$ROOT_DIR/palettes/imported/.base16-import.XXXXXX")"
  {
    printf '# RetroFX imported Base16 palette (%s)\n' "$scheme_basename"
    printf '# ANSI index order 0..15\n'
    for ((i = 0; i < 16; i++)); do
      printf '%s\n' "${BASE16_COLORS[$i]}"
    done
  } >"$tmp_palette"
  mv "$tmp_palette" "$palette_abs_path"

  tmp_profile="$(mktemp "$PROFILES_USER_DIR/.base16-profile.XXXXXX.toml")"
  {
    printf 'name = "%s"\n' "$(toml_escape_string "$profile_name")"
    printf 'version = 1\n'
    printf 'description = "%s"\n' "$(toml_escape_string "Imported from Base16 JSON: $scheme_basename")"
    printf 'tags = ["base16", "imported", "interop"]\n'
    if [[ -n "$BASE16_META_AUTHOR" ]]; then
      printf 'author = "%s"\n' "$(toml_escape_string "$BASE16_META_AUTHOR")"
    fi
    printf 'license = "Unknown"\n\n'
    printf '[mode]\n'
    printf 'type = "palette"\n\n'
    printf '[palette]\n'
    printf 'kind = "custom"\n'
    printf 'size = 16\n'
    printf 'custom_file = "%s"\n\n' "$palette_rel_path"
    printf '[effects]\n'
    printf 'blur_strength = 2\n'
    printf 'scanlines = false\n'
    printf 'flicker = false\n'
    printf 'dither = "none"\n'
    printf 'vignette = false\n\n'
    printf '[scope]\n'
    printf 'x11 = true\n'
    printf 'tty = false\n'
    printf 'tuigreet = false\n\n'
    printf '[colors]\n'
    printf 'background = "%s"\n' "${BASE16_COLORS[0]}"
    printf 'foreground = "%s"\n' "${BASE16_COLORS[5]}"
  } >"$tmp_profile"
  mv "$tmp_profile" "$profile_path"
  log "imported base16 profile '$profile_slug' from $scheme_path"
}

cmd_import() {
  local format="${1:-}"
  shift || true

  case "$format" in
    base16)
      cmd_import_base16 "$@"
      ;;
    "")
      die "import requires a format (supported: base16)"
      ;;
    *)
      die "import format must be 'base16'"
      ;;
  esac
}

cmd_gallery() {
  local pack_dir pack_name count
  local found=0

  if [[ ! -d "$PROFILES_PACKS_DIR" ]]; then
    printf 'no pack directory found at %s\n' "$PROFILES_PACKS_DIR"
    return 0
  fi

  printf 'RetroFX offline gallery\n'
  while IFS= read -r pack_dir; do
    [[ -d "$pack_dir" ]] || continue
    pack_name="$(basename "$pack_dir")"
    count="$(find "$pack_dir" -mindepth 1 -maxdepth 1 -type f -name '*.toml' | wc -l | awk '{print $1}')"
    printf '  %s (%s profiles)\n' "$pack_name" "$count"
    found=1
  done < <(find "$PROFILES_PACKS_DIR" -mindepth 1 -maxdepth 1 -type d | sort)

  if [[ "$found" -eq 0 ]]; then
    printf '  (no packs found)\n'
  fi
}

cmd_install_pack() {
  local pack_name="$1"
  local pack_dir="$PROFILES_PACKS_DIR/$pack_name"
  local src base dest copied=0 skipped=0 count=0

  [[ -d "$pack_dir" ]] || die "pack not found: $pack_name"
  mkdir -p "$PROFILES_USER_DIR"

  while IFS= read -r src; do
    [[ -f "$src" ]] || continue
    count=$((count + 1))
    base="$(basename "$src")"
    dest="$PROFILES_USER_DIR/$base"
    if [[ -e "$dest" ]]; then
      skipped=$((skipped + 1))
      continue
    fi
    cp -a "$src" "$dest"
    copied=$((copied + 1))
  done < <(find "$pack_dir" -mindepth 1 -maxdepth 1 -type f -name '*.toml' | sort)

  if [[ "$count" -eq 0 ]]; then
    warn "pack '$pack_name' has no profiles to install"
    return 0
  fi

  log "install-pack '$pack_name': copied=$copied skipped=$skipped destination=$PROFILES_USER_DIR"
}

cmd_export() {
  local format="$1"
  local profile_ref="$2"
  local out_path="$3"
  local profile_path out_dir tmp_out profile_id i key

  profile_path="$(resolve_profile_path "$profile_ref")" || die "profile not found: $profile_ref"
  profile_id="$(basename "$profile_path")"
  profile_id="${profile_id%.toml}"
  load_profile "$profile_path"

  case "$format" in
    xresources)
      build_ansi_palette
      out_dir="$(dirname -- "$out_path")"
      mkdir -p "$out_dir"
      tmp_out="$(mktemp "$out_dir/.retrofx-xresources.XXXXXX")"
      render_xresources "$tmp_out"
      mv "$tmp_out" "$out_path"
      log "exported xresources to $out_path"
      ;;
    alacritty)
      build_ansi_palette
      out_dir="$(dirname -- "$out_path")"
      mkdir -p "$out_dir"
      tmp_out="$(mktemp "$out_dir/.retrofx-alacritty.XXXXXX")"
      render_alacritty "$tmp_out"
      mv "$tmp_out" "$out_path"
      log "exported alacritty to $out_path"
      ;;
    base16)
      build_ansi_palette
      out_dir="$(dirname -- "$out_path")"
      mkdir -p "$out_dir"
      tmp_out="$(mktemp "$out_dir/.retrofx-base16.XXXXXX")"
      {
        printf '{\n'
        printf '  "system": "base16",\n'
        printf '  "generated_by": "retrofx",\n'
        printf '  "generated_at": "%s",\n' "$(now_ts)"
        printf '  "mapping": "direct-ansi-index",\n'
        printf '  "profile": "%s",\n' "$(json_escape_string "$profile_id")"
        printf '  "name": "%s",\n' "$(json_escape_string "$CFG_name")"
        for ((i = 0; i < 16; i++)); do
          key="$(printf 'base%02x' "$i")"
          if ((i == 15)); then
            printf '  "%s": "%s"\n' "$key" "${ANSI_HEX[$i]}"
          else
            printf '  "%s": "%s",\n' "$key" "${ANSI_HEX[$i]}"
          fi
        done
        printf '}\n'
      } >"$tmp_out"
      mv "$tmp_out" "$out_path"
      log "exported base16 to $out_path"
      ;;
    *)
      die "export format must be 'alacritty', 'xresources', or 'base16'"
      ;;
  esac
}

status_ok() {
  printf '[ OK ] %s\n' "$1"
}

status_warn() {
  printf '[WARN] %s\n' "$1"
}

json_bool() {
  local val="$1"
  if [[ "$val" -eq 1 ]]; then
    printf 'true'
  else
    printf 'false'
  fi
}

print_json_string_array() {
  local -n ref="$1"
  local i
  printf '['
  for ((i = 0; i < ${#ref[@]}; i++)); do
    if ((i > 0)); then
      printf ', '
    fi
    printf '"%s"' "$(json_escape_string "${ref[$i]}")"
  done
  printf ']'
}

cmd_doctor() {
  local output_mode="${1:-text}"
  local session_type wm_de mode
  local picom_installed=0
  local picom_glx=0
  local glx_runtime=0
  local glxinfo_present=0
  local glx_backend_possible=0
  local profiles_count=0
  local last_good_present=0
  local tty_backend_available=0
  local tuigreet_backend_available=0
  local session_json=""
  local -a warnings=()
  local -a errors=()
  local xdg_session="${XDG_SESSION_TYPE:-unset}"
  local template
  local -a required_templates=(
    "$TEMPLATES_DIR/shader.glsl.in"
    "$TEMPLATES_DIR/picom.conf.in"
    "$TEMPLATES_DIR/xresources.in"
    "$TEMPLATES_DIR/fontconfig.conf.in"
  )

  ensure_dirs

  mode="$(execution_mode)"
  session_type="$(detect_session_type)"
  wm_de="$(detect_wm_de)"
  case "$session_type" in
    x11)
      session_json="X11"
      ;;
    wayland)
      session_json="Wayland"
      ;;
    *)
      session_json="unknown"
      ;;
  esac

  while IFS= read -r _p; do
    [[ -n "$_p" ]] || continue
    profiles_count=$((profiles_count + 1))
  done < <(iter_all_profile_paths)

  if dir_has_files "$LAST_GOOD_DIR"; then
    last_good_present=1
  else
    warnings+=("last_good backup is empty or missing")
  fi

  [[ -x "$BACKEND_TTY" ]] && tty_backend_available=1
  [[ -x "$BACKEND_TUIGREET" ]] && tuigreet_backend_available=1

  if command -v picom >/dev/null 2>&1; then
    picom_installed=1
    if picom_has_glx; then
      picom_glx=1
    else
      warnings+=("could not confirm glx backend support from picom --help")
    fi
  else
    warnings+=("picom is not installed")
  fi

  if [[ "$session_type" == "x11" ]]; then
    if command -v glxinfo >/dev/null 2>&1; then
      glxinfo_present=1
      if glxinfo -B >/dev/null 2>&1; then
        glx_runtime=1
      else
        warnings+=("glxinfo present but GLX query failed")
      fi
    else
      warnings+=("glxinfo not found (cannot fully validate GLX runtime)")
    fi
  else
    warnings+=("GLX runtime check skipped outside X11 session")
  fi

  if [[ "$picom_installed" -eq 1 && "$picom_glx" -eq 1 ]]; then
    glx_backend_possible=1
    if [[ "$session_type" == "x11" && "$glx_runtime" -eq 0 && "$glxinfo_present" -eq 1 ]]; then
      glx_backend_possible=0
    fi
  fi

  if [[ ! -f "$ACTIVE_DIR/profile.env" || ! -f "$ACTIVE_DIR/xresources" || ! -f "$ACTIVE_DIR/semantic.env" ]]; then
    warnings+=("active config missing (run: retrofx apply <profile>)")
  fi

  if [[ "$session_type" == "wayland" ]]; then
    if [[ -f "$ACTIVE_DIR/picom.conf" || -f "$ACTIVE_DIR/shader.glsl" ]]; then
      warnings+=("wayland active state still contains x11 shader artifacts; reapply to refresh degraded outputs")
    fi
    warnings+=("Global post-process shaders are not supported in this backend.")
  fi

  if [[ "$xdg_session" != "x11" && "$xdg_session" != "wayland" ]]; then
    warnings+=("XDG_SESSION_TYPE is ${xdg_session}")
  fi

  if [[ -z "${DISPLAY:-}" ]]; then
    warnings+=("DISPLAY is not set")
  fi

  if [[ -z "${WAYLAND_DISPLAY:-}" ]]; then
    warnings+=("WAYLAND_DISPLAY is not set")
  fi

  if [[ "$profiles_count" -eq 0 ]]; then
    errors+=("no profiles found")
  fi

  for template in "${required_templates[@]}"; do
    if [[ ! -f "$template" ]]; then
      errors+=("missing template: $template")
    fi
  done

  if [[ "$output_mode" == "--json" || "$output_mode" == "json" ]]; then
    printf '{\n'
    printf '  "mode": "%s",\n' "$(json_escape_string "$mode")"
    printf '  "session": "%s",\n' "$(json_escape_string "$session_json")"
    printf '  "picom_present": %s,\n' "$(json_bool "$picom_installed")"
    printf '  "glx_backend_possible": %s,\n' "$(json_bool "$glx_backend_possible")"
    printf '  "available_profiles_count": %s,\n' "$profiles_count"
    printf '  "last_good_present": %s,\n' "$(json_bool "$last_good_present")"
    printf '  "tty_backend_available": %s,\n' "$(json_bool "$tty_backend_available")"
    printf '  "tuigreet_backend_available": %s,\n' "$(json_bool "$tuigreet_backend_available")"
    printf '  "warnings": '
    print_json_string_array warnings
    printf ',\n'
    printf '  "errors": '
    print_json_string_array errors
    printf '\n}\n'
    return 0
  fi

  printf 'RetroFX doctor\n'
  printf 'Mode: %s\n' "$mode"
  printf 'Session type: %s\n' "$session_type"
  printf 'WM/DE: %s\n' "$wm_de"

  if [[ -n "${DISPLAY:-}" ]]; then
    status_ok "DISPLAY is set to $DISPLAY"
  else
    status_warn "DISPLAY is not set (not in X11 session?)"
  fi

  if [[ -n "${WAYLAND_DISPLAY:-}" ]]; then
    status_ok "WAYLAND_DISPLAY is set to $WAYLAND_DISPLAY"
  else
    status_warn "WAYLAND_DISPLAY is not set"
  fi

  case "$xdg_session" in
    x11)
      status_ok "XDG_SESSION_TYPE is x11"
      ;;
    wayland)
      status_ok "XDG_SESSION_TYPE is wayland"
      ;;
    *)
      status_warn "XDG_SESSION_TYPE is $xdg_session"
      ;;
  esac

  if [[ "$picom_installed" -eq 1 ]]; then
    status_ok "picom is installed"
  else
    status_warn "picom is not installed"
  fi

  if [[ "$picom_installed" -eq 1 ]]; then
    if [[ "$picom_glx" -eq 1 ]]; then
      status_ok "picom advertises glx backend support"
    else
      status_warn "could not confirm glx backend support from picom --help"
    fi
  fi

  if [[ "$session_type" == "x11" ]]; then
    if command -v glxinfo >/dev/null 2>&1; then
      if [[ "$glx_runtime" -eq 1 ]]; then
        status_ok "GLX context query succeeded"
      else
        status_warn "glxinfo present but GLX query failed"
      fi
    else
      status_warn "glxinfo not found (cannot fully validate GLX runtime)"
    fi
  else
    status_warn "GLX runtime check skipped outside X11 session"
  fi

  if [[ -f "$ACTIVE_DIR/profile.env" && -f "$ACTIVE_DIR/xresources" && -f "$ACTIVE_DIR/semantic.env" ]]; then
    status_ok "active config exists"
  else
    status_warn "active config missing (run: retrofx apply <profile>)"
  fi

  if [[ "$session_type" == "wayland" ]]; then
    if [[ -f "$ACTIVE_DIR/picom.conf" || -f "$ACTIVE_DIR/shader.glsl" ]]; then
      status_warn "wayland active state still contains x11 shader artifacts; reapply to refresh degraded outputs"
    else
      status_ok "wayland active state contains degraded outputs only"
    fi
  fi

  if [[ "$last_good_present" -eq 1 ]]; then
    status_ok "last_good backup exists"
  else
    status_warn "last_good backup is empty or missing"
  fi

  printf 'Capabilities:\n'
  if [[ "$session_type" == "x11" ]]; then
    if [[ "$glx_backend_possible" -eq 1 ]]; then
      status_ok "X11 backend: full shader pipeline available"
    else
      status_warn "X11 backend: full shader pipeline requires picom + glx"
    fi
  elif [[ "$session_type" == "wayland" ]]; then
    status_warn "Global post-process shaders are not supported in this backend."
    status_ok "Wayland backend: degraded outputs only (no global shader pipeline)"
  else
    status_warn "Session backend unknown; assuming degraded-safe behavior"
  fi

  status_ok "Terminal palette export: xresources + ANSI semantic env"
  if [[ "$tty_backend_available" -eq 1 ]]; then
    status_ok "TTY backend available"
  else
    status_warn "TTY backend unavailable"
  fi
  if [[ "$tuigreet_backend_available" -eq 1 ]]; then
    status_ok "Tuigreet backend available"
  else
    status_warn "Tuigreet backend unavailable"
  fi

  if ((${#errors[@]} > 0)); then
    printf 'Errors:\n'
    local err
    for err in "${errors[@]}"; do
      printf '  - %s\n' "$err"
    done
  fi
}

preview_truecolor_block() {
  local r="$1"
  local g="$2"
  local b="$3"
  printf '\033[48;2;%d;%d;%dm  \033[0m' "$r" "$g" "$b"
}

cmd_preview() {
  local mode="passthrough"
  local bands=8
  local phosphor_r="1.000000"
  local phosphor_g="1.000000"
  local phosphor_b="1.000000"

  if [[ $# -gt 0 ]]; then
    local profile_path
    profile_path="$(resolve_profile_path "$1")" || die "profile not found: $1"
    load_profile "$profile_path"

    mode="$CFG_mode_type"
    bands="$CFG_monochrome_bands"
    phosphor_r="$CFG_phosphor_r"
    phosphor_g="$CFG_phosphor_g"
    phosphor_b="$CFG_phosphor_b"
  elif [[ -f "$ACTIVE_DIR/profile.env" ]]; then
    # shellcheck source=/dev/null
    source "$ACTIVE_DIR/profile.env"
    mode="${MODE_TYPE:-passthrough}"
    bands="${MONO_BANDS:-8}"
    phosphor_r="${PHOSPHOR_R:-1.000000}"
    phosphor_g="${PHOSPHOR_G:-1.000000}"
    phosphor_b="${PHOSPHOR_B:-1.000000}"
  fi

  if [[ $# -eq 0 && -f "$ACTIVE_DIR/profile.env" ]]; then
    CFG_mode_type="${MODE_TYPE:-$mode}"
    CFG_monochrome_bands="${MONO_BANDS:-$bands}"
    CFG_palette_kind="${PALETTE_KIND:-vga16}"
    CFG_palette_size="${PALETTE_SIZE:-16}"
    CFG_phosphor_r="${PHOSPHOR_R:-$phosphor_r}"
    CFG_phosphor_g="${PHOSPHOR_G:-$phosphor_g}"
    CFG_phosphor_b="${PHOSPHOR_B:-$phosphor_b}"
    CFG_colors_background="${COLOR_BACKGROUND:-}"
    CFG_colors_foreground="${COLOR_FOREGROUND:-}"
    compute_color_knobs
  elif [[ $# -eq 0 ]]; then
    CFG_mode_type="$mode"
    CFG_monochrome_bands="$bands"
    CFG_palette_kind="vga16"
    CFG_palette_size="16"
    CFG_phosphor_r="$phosphor_r"
    CFG_phosphor_g="$phosphor_g"
    CFG_phosphor_b="$phosphor_b"
    CFG_colors_background=""
    CFG_colors_foreground=""
    compute_color_knobs
  fi

  build_ansi_palette

  printf 'Grayscale ramp\n'
  local i v
  for ((i = 0; i < 32; i++)); do
    v=$((i * 255 / 31))
    preview_truecolor_block "$v" "$v" "$v"
  done
  printf '\n\n'

  printf 'Band visualization (%s, %s bands)\n' "$mode" "$bands"
  local levels
  levels="$bands"
  if [[ "$levels" -lt 2 ]]; then
    levels=2
  fi
  if [[ "$levels" -gt 256 ]]; then
    levels=256
  fi

  local pr pg pb
  pr="$(float_to_u8 "$phosphor_r")"
  pg="$(float_to_u8 "$phosphor_g")"
  pb="$(float_to_u8 "$phosphor_b")"

  local lum q out r g b
  for ((i = 0; i < 64; i++)); do
    lum=$((i * 255 / 63))
    q=$(((lum * (levels - 1) + 127) / 255))
    out=$((q * 255 / (levels - 1)))

    r=$((out * pr / 255))
    g=$((out * pg / 255))
    b=$((out * pb / 255))
    preview_truecolor_block "$r" "$g" "$b"
  done
  printf '\n\n'

  printf 'Band indices numeric (%d levels)\n' "$levels"
  for ((i = 0; i < levels; i++)); do
    printf '%d ' "$i"
    if (((i + 1) % 32 == 0)); then
      printf '\n'
    fi
  done
  printf '\n\n'

  printf 'Quantization demo (input -> band -> output)\n'
  local sample band_idx band_out
  for sample in 0 32 64 96 128 160 192 224 255; do
    band_idx=$(((sample * (levels - 1) + 127) / 255))
    band_out=$((band_idx * 255 / (levels - 1)))
    printf '%3d -> %3d -> %3d\n' "$sample" "$band_idx" "$band_out"
  done
  printf '\n'

  printf 'Derived ANSI16 palette (profile-based)\n'
  local i ansi_hex rgb
  for ((i = 0; i < 16; i++)); do
    ansi_hex="${ANSI_HEX[$i]}"
    rgb="$(hex_to_rgb_triplet "$ansi_hex")"
    IFS=',' read -r r g b <<<"$rgb"
    printf '%02d %-8s ' "$i" "$ansi_hex"
    preview_truecolor_block "$r" "$g" "$b"
    printf '\n'
  done
  printf '\n'

  printf 'Semantic color table\n'
  printf 'background %s\n' "$SEM_BACKGROUND"
  printf 'normal     %s\n' "$SEM_NORMAL"
  printf 'dim        %s\n' "$SEM_DIM"
  printf 'bright     %s\n' "$SEM_BRIGHT"
  printf 'info       %s\n' "$SEM_INFO"
  printf 'success    %s\n' "$SEM_SUCCESS"
  printf 'warning    %s\n' "$SEM_WARNING"
  printf 'error      %s\n' "$SEM_ERROR"
  printf '\n'

  if [[ "$mode" == "monochrome" ]]; then
    printf 'Monochrome band-to-ANSI mapping\n'
    local lum_from_hex
    for ((i = 0; i < 16; i++)); do
      lum_from_hex="$(brightness_from_hex "${ANSI_HEX[$i]}")"
      band_idx=$(((lum_from_hex * (levels - 1) + 127) / 255))
      printf 'ansi%-2d -> band %-3d (%s)\n' "$i" "$band_idx" "${ANSI_HEX[$i]}"
    done
    printf '\n'
  fi

  printf 'ANSI 16 swatches\n'
  local code ansi
  for ((code = 0; code < 16; code++)); do
    if ((code < 8)); then
      ansi=$((40 + code))
    else
      ansi=$((100 + code - 8))
    fi
    printf '\033[%dm %02d \033[0m' "$ansi" "$code"
  done
  printf '\n\n'

  local rr gg bb idx
  printf 'cube256 index grid (g layers, r rows, b columns)\n'
  for ((gg = 0; gg < 6; gg++)); do
    printf 'g=%d\n' "$gg"
    for ((rr = 0; rr < 6; rr++)); do
      for ((bb = 0; bb < 6; bb++)); do
        idx=$((16 + 36 * rr + 6 * gg + bb))
        printf '%3d ' "$idx"
      done
      printf '\n'
    done
  done
  printf '\n'

  printf 'cube256 swatches\n'
  for ((gg = 0; gg < 6; gg++)); do
    for ((rr = 0; rr < 6; rr++)); do
      for ((bb = 0; bb < 6; bb++)); do
        idx=$((16 + 36 * rr + 6 * gg + bb))
        printf '\033[48;5;%dm  \033[0m' "$idx"
      done
      printf ' '
    done
    printf '\n'
  done
  printf 'grayscale: '
  for ((idx = 232; idx <= 255; idx++)); do
    printf '\033[48;5;%dm  \033[0m' "$idx"
  done
  printf '\n'
}

prompt_input() {
  local prompt="$1"
  local default="$2"
  local value=""

  while true; do
    if [[ -n "$default" ]]; then
      read -r -p "$prompt [$default]: " value || return 1
      value="${value:-$default}"
    else
      read -r -p "$prompt: " value || return 1
    fi

    value="$(trim "$value")"
    if [[ -n "$value" ]]; then
      printf '%s' "$value"
      return 0
    fi
  done
}

prompt_optional_input() {
  local prompt="$1"
  local default="$2"
  local value=""

  if [[ -n "$default" ]]; then
    read -r -p "$prompt [$default]: " value || return 1
    value="${value:-$default}"
  else
    read -r -p "$prompt: " value || return 1
  fi

  value="$(trim "$value")"
  printf '%s' "$value"
}

prompt_yes_no() {
  local prompt="$1"
  local default="$2"
  local answer=""

  while true; do
    read -r -p "$prompt [$default]: " answer || return 1
    answer="$(trim "${answer:-$default}")"
    case "$answer" in
      y | Y | yes | YES | true)
        printf 'true'
        return 0
        ;;
      n | N | no | NO | false)
        printf 'false'
        return 0
        ;;
      *)
        printf 'Please answer y or n.\n' >&2
        ;;
    esac
  done
}

prompt_select_option() {
  local prompt="$1"
  shift
  local options=("$@")
  local choice=""

  printf '%s\n' "$prompt" >&2
  select choice in "${options[@]}"; do
    if [[ -n "$choice" ]]; then
      printf '%s' "$choice"
      return 0
    fi
    printf 'Please select a valid number.\n' >&2
  done
}

slugify_filename() {
  local value="$1"
  value="$(printf '%s' "$value" | tr '[:upper:]' '[:lower:]' | tr -cs 'a-z0-9._-' '-')"
  value="${value#-}"
  value="${value%-}"
  if [[ -z "$value" ]]; then
    value="profile"
  fi
  printf '%s' "$value"
}

toml_escape_string() {
  local value="$1"
  value="${value//\\/\\\\}"
  value="${value//\"/\\\"}"
  printf '%s' "$value"
}

tags_csv_to_toml_array() {
  local raw="$1"
  local item escaped out=""
  local -a parts=()
  IFS=',' read -r -a parts <<<"$raw"

  for item in "${parts[@]}"; do
    item="$(trim "$item")"
    [[ -z "$item" ]] && continue
    escaped="$(toml_escape_string "$item")"
    if [[ -z "$out" ]]; then
      out="\"$escaped\""
    else
      out="$out, \"$escaped\""
    fi
  done

  if [[ -z "$out" ]]; then
    printf ''
  else
    printf '[%s]' "$out"
  fi
}

apply_effect_preset() {
  local preset="$1"
  case "$preset" in
    subtle)
      EFFECT_PRESET_BLUR="2"
      EFFECT_PRESET_SCANLINES="false"
      EFFECT_PRESET_FLICKER="false"
      EFFECT_PRESET_DITHER="none"
      EFFECT_PRESET_VIGNETTE="false"
      ;;
    crt)
      EFFECT_PRESET_BLUR="3"
      EFFECT_PRESET_SCANLINES="true"
      EFFECT_PRESET_FLICKER="false"
      EFFECT_PRESET_DITHER="ordered"
      EFFECT_PRESET_VIGNETTE="false"
      ;;
    vfd)
      EFFECT_PRESET_BLUR="3"
      EFFECT_PRESET_SCANLINES="false"
      EFFECT_PRESET_FLICKER="true"
      EFFECT_PRESET_DITHER="ordered"
      EFFECT_PRESET_VIGNETTE="false"
      ;;
    raw)
      EFFECT_PRESET_BLUR="0"
      EFFECT_PRESET_SCANLINES="false"
      EFFECT_PRESET_FLICKER="false"
      EFFECT_PRESET_DITHER="none"
      EFFECT_PRESET_VIGNETTE="false"
      ;;
    *)
      die "unknown preset '$preset'"
      ;;
  esac
}

next_available_user_profile_path() {
  local base_slug="$1"
  local candidate="$PROFILES_USER_DIR/$base_slug.toml"
  local n=1

  while [[ -e "$candidate" ]]; do
    candidate="$PROFILES_USER_DIR/$base_slug-$n.toml"
    n=$((n + 1))
  done

  printf '%s' "$candidate"
}

write_profile_toml() {
  local out_path="$1"
  local name="$2"
  local description="$3"
  local tags_csv="$4"
  local author="$5"
  local license_name="$6"
  local mode="$7"
  local mono_bands="$8"
  local mono_phosphor="$9"
  local mono_custom="${10}"
  local mono_hotcore="${11}"
  local pal_kind="${12}"
  local pal_size="${13}"
  local pal_custom="${14}"
  local eff_blur="${15}"
  local eff_scan="${16}"
  local eff_flicker="${17}"
  local eff_dither="${18}"
  local eff_vignette="${19}"
  local scope_x11="${20}"
  local scope_tty="${21}"
  local scope_tuigreet="${22}"
  local tmp_path tags_array escaped

  mkdir -p "$(dirname -- "$out_path")"
  tmp_path="$(mktemp "$(dirname -- "$out_path")/.new-profile.XXXXXX")"
  tags_array="$(tags_csv_to_toml_array "$tags_csv")"

  {
    escaped="$(toml_escape_string "$name")"
    printf 'name = "%s"\n' "$escaped"
    printf 'version = 1\n'

    if [[ -n "$description" ]]; then
      escaped="$(toml_escape_string "$description")"
      printf 'description = "%s"\n' "$escaped"
    fi
    if [[ -n "$tags_array" ]]; then
      printf 'tags = %s\n' "$tags_array"
    fi
    if [[ -n "$author" ]]; then
      escaped="$(toml_escape_string "$author")"
      printf 'author = "%s"\n' "$escaped"
    fi
    if [[ -n "$license_name" ]]; then
      escaped="$(toml_escape_string "$license_name")"
      printf 'license = "%s"\n' "$escaped"
    fi
    printf '\n'

    printf '[mode]\n'
    printf 'type = "%s"\n\n' "$mode"

    if [[ "$mode" == "monochrome" ]]; then
      printf '[monochrome]\n'
      printf 'bands = %s\n' "$mono_bands"
      printf 'phosphor = "%s"\n' "$mono_phosphor"
      if [[ "$mono_phosphor" == "custom" ]]; then
        printf 'custom_rgb = "%s"\n' "$mono_custom"
      fi
      printf 'hotcore = %s\n\n' "$mono_hotcore"
    fi

    if [[ "$mode" == "palette" ]]; then
      printf '[palette]\n'
      printf 'kind = "%s"\n' "$pal_kind"
      printf 'size = %s\n' "$pal_size"
      if [[ "$pal_kind" == "custom" ]]; then
        escaped="$(toml_escape_string "$pal_custom")"
        printf 'custom_file = "%s"\n' "$escaped"
      fi
      printf '\n'
    fi

    printf '[effects]\n'
    printf 'blur_strength = %s\n' "$eff_blur"
    printf 'scanlines = %s\n' "$eff_scan"
    printf 'flicker = %s\n' "$eff_flicker"
    printf 'dither = "%s"\n' "$eff_dither"
    printf 'vignette = %s\n\n' "$eff_vignette"

    printf '[scope]\n'
    printf 'x11 = %s\n' "$scope_x11"
    printf 'tty = %s\n' "$scope_tty"
    printf 'tuigreet = %s\n' "$scope_tuigreet"
  } >"$tmp_path"

  mv "$tmp_path" "$out_path"
}

cmd_new_noninteractive() {
  local name filename out_path
  name="Wizard Default Profile"
  filename="wizard-default"
  out_path="$(next_available_user_profile_path "$filename")"

  apply_effect_preset "subtle"
  write_profile_toml \
    "$out_path" \
    "$name" \
    "Generated by non-interactive RetroFX wizard mode." \
    "user,wizard,default" \
    "RetroFX Wizard" \
    "" \
    "monochrome" \
    "8" \
    "green" \
    "" \
    "false" \
    "vga16" \
    "16" \
    "" \
    "$EFFECT_PRESET_BLUR" \
    "$EFFECT_PRESET_SCANLINES" \
    "$EFFECT_PRESET_FLICKER" \
    "$EFFECT_PRESET_DITHER" \
    "$EFFECT_PRESET_VIGNETTE" \
    "true" \
    "false" \
    "false"

  log "wrote new profile: $out_path"
}

cmd_new() {
  local wizard_mode display_type color intensity look preset
  local name description tags author license_name filename out_path
  local mode mono_bands mono_phosphor mono_custom mono_hotcore
  local pal_kind pal_size pal_custom
  local eff_blur eff_scan eff_flicker eff_dither eff_vignette
  local scope_x11 scope_tty scope_tuigreet

  mkdir -p "$PROFILES_USER_DIR"

  if [[ "${RETROFX_WIZARD_NONINTERACTIVE:-0}" == "1" ]]; then
    cmd_new_noninteractive
    return 0
  fi

  [[ -t 0 ]] || die "retrofx new requires an interactive terminal (or RETROFX_WIZARD_NONINTERACTIVE=1)"

  name="$(prompt_input "Profile name" "My RetroFX Profile")" || exit 1
  description="$(prompt_optional_input "Description (optional, one line)" "")" || exit 1
  tags="$(prompt_optional_input "Tags (comma-separated, optional)" "user,custom")" || exit 1
  author="$(prompt_optional_input "Author (optional)" "")" || exit 1
  license_name="$(prompt_optional_input "License (optional)" "")" || exit 1

  wizard_mode="$(prompt_select_option "Wizard mode:" "Beginner" "Advanced")" || exit 1

  mode="monochrome"
  mono_bands="8"
  mono_phosphor="green"
  mono_custom=""
  mono_hotcore="false"
  pal_kind="vga16"
  pal_size="16"
  pal_custom=""
  scope_x11="true"
  scope_tty="false"
  scope_tuigreet="false"
  preset="subtle"

  if [[ "$wizard_mode" == "Beginner" ]]; then
    display_type="$(prompt_select_option "Display type:" "CRT" "VFD" "LCD" "Terminal" "Custom")" || exit 1
    color="$(prompt_select_option "Color tone:" "green" "amber" "blue" "white" "custom")" || exit 1
    intensity="$(prompt_select_option "Intensity mode:" "4" "6" "8" "12" "16" "vga16" "cube256")" || exit 1
    look="$(prompt_select_option "Look strength:" "subtle" "medium" "strong")" || exit 1

    if [[ "$intensity" == "vga16" || "$intensity" == "cube256" ]]; then
      mode="palette"
      pal_kind="$intensity"
      if [[ "$intensity" == "cube256" ]]; then
        pal_size="256"
      else
        pal_size="16"
      fi
    else
      mode="monochrome"
      mono_bands="$intensity"
      mono_phosphor="$color"
      if [[ "$color" == "custom" ]]; then
        while true; do
          mono_custom="$(prompt_input "Custom RGB (r,g,b in 0..1 or 0..255)" "0.7,1.0,0.7")" || exit 1
          if mono_custom="$(normalize_rgb_triplet "$mono_custom")"; then
            break
          fi
          printf 'Invalid RGB triplet\n' >&2
        done
      fi
      if [[ "$display_type" == "VFD" ]]; then
        mono_hotcore="true"
      fi
    fi

    case "$look" in
      subtle)
        preset="subtle"
        ;;
      medium)
        if [[ "$display_type" == "VFD" ]]; then
          preset="vfd"
        elif [[ "$display_type" == "LCD" ]]; then
          preset="subtle"
        else
          preset="crt"
        fi
        ;;
      strong)
        if [[ "$display_type" == "VFD" ]]; then
          preset="vfd"
        elif [[ "$display_type" == "LCD" ]]; then
          preset="crt"
        else
          preset="crt"
        fi
        ;;
    esac
  else
    mode="$(prompt_select_option "Mode:" "passthrough" "monochrome" "palette")" || exit 1
    if [[ "$mode" == "monochrome" ]]; then
      while true; do
        mono_bands="$(prompt_input "Monochrome bands (2-256)" "8")" || exit 1
        if parse_int_range "$mono_bands" 2 256 >/dev/null; then
          break
        fi
        printf 'bands must be 2..256\n' >&2
      done

      mono_phosphor="$(prompt_select_option "Phosphor:" "green" "amber" "blue" "white" "custom")" || exit 1
      if [[ "$mono_phosphor" == "custom" ]]; then
        while true; do
          mono_custom="$(prompt_input "Custom RGB (r,g,b in 0..1 or 0..255)" "0.7,1.0,0.7")" || exit 1
          if mono_custom="$(normalize_rgb_triplet "$mono_custom")"; then
            break
          fi
          printf 'Invalid RGB triplet\n' >&2
        done
      fi
      mono_hotcore="$(prompt_yes_no "Enable hot-core whitening? (y/n)" "n")" || exit 1
    fi

    if [[ "$mode" == "palette" ]]; then
      pal_kind="$(prompt_select_option "Palette kind:" "vga16" "cube256" "custom")" || exit 1
      while true; do
        if [[ "$pal_kind" == "cube256" ]]; then
          pal_size="$(prompt_input "Palette size (2-256)" "256")" || exit 1
        else
          pal_size="$(prompt_input "Palette size (2-256)" "16")" || exit 1
        fi
        if parse_int_range "$pal_size" 2 256 >/dev/null; then
          break
        fi
        printf 'size must be 2..256\n' >&2
      done
      if [[ "$pal_kind" == "custom" ]]; then
        pal_custom="$(prompt_input "Custom palette file path" "palette.txt")" || exit 1
      fi
    fi

    preset="$(prompt_select_option "Safe effects preset:" "subtle" "crt" "vfd" "raw")" || exit 1
  fi

  apply_effect_preset "$preset"
  eff_blur="$EFFECT_PRESET_BLUR"
  eff_scan="$EFFECT_PRESET_SCANLINES"
  eff_flicker="$EFFECT_PRESET_FLICKER"
  eff_dither="$EFFECT_PRESET_DITHER"
  eff_vignette="$EFFECT_PRESET_VIGNETTE"

  if [[ "$wizard_mode" == "Advanced" ]]; then
    if [[ "$(prompt_yes_no "Override preset effects manually? (y/n)" "n")" == "true" ]]; then
      while true; do
        eff_blur="$(prompt_input "Blur strength (0-6)" "$eff_blur")" || exit 1
        if parse_int_range "$eff_blur" 0 6 >/dev/null; then
          break
        fi
        printf 'blur_strength must be 0..6\n' >&2
      done
      eff_scan="$(prompt_yes_no "Enable scanlines? (y/n)" "$( [[ "$eff_scan" == "true" ]] && printf y || printf n )")" || exit 1
      eff_flicker="$(prompt_yes_no "Enable flicker? (y/n)" "$( [[ "$eff_flicker" == "true" ]] && printf y || printf n )")" || exit 1
      while true; do
        eff_dither="$(prompt_input "Dither (none/ordered)" "$eff_dither")" || exit 1
        case "$eff_dither" in
          none | ordered)
            break
            ;;
        esac
        printf 'dither must be none or ordered\n' >&2
      done
      eff_vignette="$(prompt_yes_no "Enable vignette? (y/n)" "$( [[ "$eff_vignette" == "true" ]] && printf y || printf n )")" || exit 1
    fi
  fi

  scope_x11="$(prompt_yes_no "Enable X11 scope? (y/n)" "y")" || exit 1
  scope_tty="$(prompt_yes_no "Enable TTY scope? (y/n)" "n")" || exit 1
  scope_tuigreet="$(prompt_yes_no "Enable tuigreet scope? (y/n)" "n")" || exit 1

  filename="$(prompt_input "Profile filename (without .toml)" "$(slugify_filename "$name")")" || exit 1
  filename="$(slugify_filename "$filename")"
  out_path="$PROFILES_USER_DIR/$filename.toml"

  if [[ -e "$out_path" ]]; then
    if [[ "$(prompt_yes_no "Profile exists at $out_path. Overwrite? (y/n)" "n")" != "true" ]]; then
      die "aborted"
    fi
  fi

  write_profile_toml \
    "$out_path" \
    "$name" \
    "$description" \
    "$tags" \
    "$author" \
    "$license_name" \
    "$mode" \
    "$mono_bands" \
    "$mono_phosphor" \
    "$mono_custom" \
    "$mono_hotcore" \
    "$pal_kind" \
    "$pal_size" \
    "$pal_custom" \
    "$eff_blur" \
    "$eff_scan" \
    "$eff_flicker" \
    "$eff_dither" \
    "$eff_vignette" \
    "$scope_x11" \
    "$scope_tty" \
    "$scope_tuigreet"

  log "wrote new profile: $out_path"
}

cmd_apply() {
  local profile_ref="$1"
  local profile_path stage_dir profile_id session_type

  ensure_dirs
  profile_path="$(resolve_profile_path "$profile_ref")" || die "profile not found: $profile_ref"
  profile_id="$(basename "$profile_path")"
  profile_id="${profile_id%.toml}"
  session_type="$(detect_session_type)"

  load_profile "$profile_path"

  TXN_ACTIVE=1
  TXN_STAGE_DIR=""
  stage_dir="$(mktemp -d "$STATE_DIR/stage.$(now_ts_compact).$$.XXXXXX")"
  TXN_STAGE_DIR="$stage_dir"

  render_templates "$stage_dir" "$profile_path" "$session_type"

  if ! validate_stage_with_picom "$stage_dir" "$session_type"; then
    LAST_ERROR="validation failed for profile '$profile_id'"
    warn "$LAST_ERROR"
    return 1
  fi

  if ! backup_active "$profile_id"; then
    LAST_ERROR="failed to back up active state"
    return 1
  fi

  if ! atomic_swap_active "$stage_dir"; then
    LAST_ERROR="unable to atomically swap active configuration"
    return 1
  fi

  TXN_STAGE_DIR=""

  if [[ "$session_type" == "wayland" ]]; then
    if [[ -f "$ACTIVE_DIR/shader.glsl" || -f "$ACTIVE_DIR/picom.conf" ]]; then
      LAST_ERROR="wayland active state must not contain x11 shader targets"
      restore_last_good || true
      TXN_ACTIVE=0
      return 1
    fi
  elif [[ ! -f "$ACTIVE_DIR/shader.glsl" ]]; then
    LAST_ERROR="active/shader.glsl missing after swap"
    restore_last_good || true
    TXN_ACTIVE=0
    return 1
  fi

  prune_backups "$BACKUP_KEEP"

  if ! apply_scoped_backends "$session_type"; then
    restore_last_good || true
    TXN_ACTIVE=0
    return 1
  fi

  if ! copy_active_to_last_good; then
    LAST_ERROR="failed to update last_good snapshot"
    restore_last_good || true
    TXN_ACTIVE=0
    return 1
  fi

  restart_picom_if_running || true

  TXN_ACTIVE=0
  if [[ "$session_type" == "wayland" ]]; then
    log "Wayland session detected: shader pipeline disabled; applied degraded outputs only."
  fi
  log "applied profile '$profile_id'"
}

cmd_off_profile() {
  local skip_tty_restore="${1:-false}"
  local session_type old_scope_tty
  old_scope_tty="false"

  ensure_dirs

  session_type="$(detect_session_type)"
  if [[ -f "$ACTIVE_DIR/profile.env" ]]; then
    # shellcheck source=/dev/null
    source "$ACTIVE_DIR/profile.env"
    old_scope_tty="${SCOPE_TTY:-false}"
  fi

  if [[ -f "$PROFILES_DIR/passthrough.toml" ]]; then
    cmd_apply "passthrough" || return 1
  else
    warn "profiles/passthrough.toml missing; using built-in passthrough"
    local tmp
    tmp="$(mktemp "$STATE_DIR/passthrough.$(now_ts_compact).$$.XXXXXX.toml")"
    create_builtin_passthrough_profile "$tmp"

    if ! cmd_apply "$tmp"; then
      rm -f "$tmp"
      return 1
    fi
    rm -f "$tmp"
  fi

  if [[ "$skip_tty_restore" != "true" && "$session_type" == "wayland" && "$old_scope_tty" == "true" ]]; then
    cmd_off_tty || return 1
  fi
}

cmd_off_tty() {
  ensure_dirs
  if [[ ! -x "$BACKEND_TTY" ]]; then
    warn "tty backend is unavailable"
    return 0
  fi
  "$BACKEND_TTY" off "$ACTIVE_DIR"
}

cmd_off() {
  local mode="${1:---profile}"
  local rc=0
  case "$mode" in
    --profile)
      cmd_off_profile "false"
      ;;
    --tty)
      cmd_off_tty
      ;;
    --all)
      if ! cmd_off_profile "true"; then
        rc=1
      fi
      if ! cmd_off_tty; then
        rc=1
      fi
      return "$rc"
      ;;
    *)
      die "off accepts only --tty or --all"
      ;;
  esac
}

copy_install_payload() {
  local stage_dir="$1"
  local src_root="$SELF_ROOT_DIR"
  local item

  mkdir -p "$stage_dir"
  for item in backends templates scripts profiles docs palettes README.md VERSION CHANGELOG.md; do
    if [[ -e "$src_root/$item" ]]; then
      cp -a "$src_root/$item" "$stage_dir/$item"
    fi
  done

  # User profiles are preserved from the destination tree; do not overwrite from source.
  rm -rf "$stage_dir/profiles/user"
  mkdir -p "$stage_dir/profiles/user" "$stage_dir/active" "$stage_dir/state"
}

backup_existing_user_profiles() {
  local existing_home="$1"
  local out_dir="$2"

  if dir_has_files "$existing_home/profiles/user"; then
    mkdir -p "$out_dir"
    cp -a "$existing_home/profiles/user"/. "$out_dir"/
  fi
}

preserve_existing_install_state() {
  local existing_home="$1"
  local stage_dir="$2"

  if [[ -d "$existing_home/active" ]]; then
    rm -rf "$stage_dir/active"
    cp -a "$existing_home/active" "$stage_dir/active"
  fi

  if [[ -d "$existing_home/state" ]]; then
    rm -rf "$stage_dir/state"
    cp -a "$existing_home/state" "$stage_dir/state"
  fi

  if [[ -d "$existing_home/profiles/user" ]]; then
    mkdir -p "$stage_dir/profiles/user"
    cp -a "$existing_home/profiles/user"/. "$stage_dir/profiles/user"/
  fi
}

write_install_marker() {
  local install_home="$1"
  local stage_dir="$2"

  {
    printf 'managed=true\n'
    printf 'installed_at=%s\n' "$(now_ts)"
    printf 'install_home=%s\n' "$install_home"
    printf 'source_root=%s\n' "$SELF_ROOT_DIR"
  } >"$stage_dir/$INSTALL_MARKER_FILE"
}

atomic_replace_tree() {
  local target_dir="$1"
  local stage_dir="$2"
  local parent_dir old_dir

  parent_dir="$(dirname -- "$target_dir")"
  mkdir -p "$parent_dir"
  old_dir="$parent_dir/.retrofx-old.$$.${RANDOM}"
  rm -rf "$old_dir"

  if [[ -d "$target_dir" ]]; then
    mv "$target_dir" "$old_dir"
  fi

  if mv "$stage_dir" "$target_dir"; then
    rm -rf "$old_dir"
    return 0
  fi

  warn "install swap failed; restoring previous install tree"
  rm -rf "$target_dir"
  if [[ -d "$old_dir" ]]; then
    mv "$old_dir" "$target_dir"
  fi
  return 1
}

launcher_is_managed() {
  local launcher="$1"
  [[ -f "$launcher" ]] || return 1
  grep -Fq '# RetroFX launcher (managed)' "$launcher"
}

launcher_points_to_home() {
  local launcher="$1"
  local install_home="$2"
  [[ -f "$launcher" ]] || return 1
  grep -Fq "$install_home/scripts/retrofx" "$launcher"
}

write_launcher() {
  local install_home="$1"
  local launcher_path="$DEFAULT_LAUNCHER_PATH"
  local launcher_dir tmp_launcher backup_dir

  launcher_dir="$(dirname -- "$launcher_path")"
  mkdir -p "$launcher_dir"

  if [[ -f "$launcher_path" ]] && ! launcher_is_managed "$launcher_path"; then
    backup_dir="$install_home/state/install-backups/launcher-$(now_ts_compact)-pid$$"
    mkdir -p "$backup_dir"
    cp -a "$launcher_path" "$backup_dir/retrofx.launcher.backup"
  fi

  tmp_launcher="$(mktemp "$launcher_dir/.retrofx-launcher.XXXXXX")"
  {
    printf '#!/usr/bin/env bash\n'
    printf 'set -euo pipefail\n'
    printf '# RetroFX launcher (managed)\n'
    printf 'export RETROFX_HOME=%q\n' "$install_home"
    printf 'exec %q "$@"\n' "$install_home/scripts/retrofx"
  } >"$tmp_launcher"
  chmod 755 "$tmp_launcher"
  mv "$tmp_launcher" "$launcher_path"
}

remove_managed_xsessions() {
  local xs_dir="${XDG_DATA_HOME:-$HOME/.local/share}/xsessions"
  local removed=0
  local file

  [[ -d "$xs_dir" ]] || {
    printf '0'
    return 0
  }

  while IFS= read -r file; do
    [[ -f "$file" ]] || continue
    if grep -Fxq "$XS_MARKER_KEY" "$file" || grep -Fq '# RetroFX-Managed: true' "$file"; then
      rm -f "$file"
      removed=$((removed + 1))
    fi
  done < <(find "$xs_dir" -mindepth 1 -maxdepth 1 -type f -name '*.desktop' | sort)

  printf '%s' "$removed"
}

cmd_install() {
  local auto_yes="false"
  local target_home="$DEFAULT_INSTALL_HOME"
  local stage_dir=""
  local backup_user_dir=""
  local profile="-"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --yes)
        auto_yes="true"
        shift
        ;;
      --path)
        [[ $# -ge 2 ]] || die "--path requires a directory argument"
        target_home="$2"
        shift 2
        ;;
      *)
        die "install accepts only --yes and optional --path <dir>"
        ;;
    esac
  done

  target_home="$(expand_user_path "$target_home")"
  [[ "$target_home" == /* ]] || target_home="$PWD/$target_home"
  target_home="${target_home%/}"
  [[ -n "$target_home" && "$target_home" != "/" ]] || die "invalid install path"

  confirm_or_die "Install RetroFX to $target_home?" "$auto_yes"

  stage_dir="$(mktemp -d "/tmp/retrofx-install-stage.$$.XXXXXX")"
  copy_install_payload "$stage_dir"

  if [[ -d "$target_home" ]]; then
    backup_user_dir="$target_home/state/install-backups/user-profiles-$(now_ts_compact)-pid$$"
    backup_existing_user_profiles "$target_home" "$backup_user_dir"
    preserve_existing_install_state "$target_home" "$stage_dir"
  fi

  write_install_marker "$target_home" "$stage_dir"

  if ! atomic_replace_tree "$target_home" "$stage_dir"; then
    rm -rf "$stage_dir"
    append_home_log "$target_home" "install" "$profile" "failure" "atomic swap failed"
    die "install failed while replacing target directory"
  fi

  if ! write_launcher "$target_home"; then
    append_home_log "$target_home" "install" "$profile" "failure" "launcher write failed"
    die "install completed but launcher setup failed"
  fi

  append_home_log "$target_home" "install" "$profile" "success" "source=$SELF_ROOT_DIR"
  log "installed RetroFX to $target_home"
  log "launcher written to $DEFAULT_LAUNCHER_PATH"
}

cmd_uninstall() {
  local auto_yes="false"
  local keep_profiles="false"
  local target_home="${RETROFX_HOME:-$DEFAULT_INSTALL_HOME}"
  local kept_profiles_dir=""
  local removed_xsessions=0

  while [[ $# -gt 0 ]]; do
    case "$1" in
      --yes)
        auto_yes="true"
        shift
        ;;
      --keep-profiles)
        keep_profiles="true"
        shift
        ;;
      *)
        die "uninstall accepts only --yes and optional --keep-profiles"
        ;;
    esac
  done

  target_home="$(expand_user_path "$target_home")"
  [[ "$target_home" == /* ]] || target_home="$PWD/$target_home"
  target_home="${target_home%/}"
  [[ -n "$target_home" && "$target_home" != "/" ]] || die "invalid uninstall path"
  [[ -d "$target_home" ]] || die "install directory not found: $target_home"

  if [[ ! -f "$target_home/$INSTALL_MARKER_FILE" ]]; then
    warn "install marker not found under $target_home; proceeding with caution"
  fi

  confirm_or_die "Uninstall RetroFX from $target_home?" "$auto_yes"

  append_home_log "$target_home" "uninstall" "-" "start" "keep_profiles=$keep_profiles"

  if [[ "$keep_profiles" == "true" ]] && dir_has_files "$target_home/profiles/user"; then
    kept_profiles_dir="${target_home}-profiles-$(now_ts_compact)"
    mkdir -p "$kept_profiles_dir"
    cp -a "$target_home/profiles/user" "$kept_profiles_dir/user"
  fi

  if [[ -e "$DEFAULT_LAUNCHER_PATH" ]] && (launcher_is_managed "$DEFAULT_LAUNCHER_PATH" || launcher_points_to_home "$DEFAULT_LAUNCHER_PATH" "$target_home"); then
    rm -f "$DEFAULT_LAUNCHER_PATH"
  fi

  removed_xsessions="$(remove_managed_xsessions)"
  rm -rf "$target_home"

  if [[ -n "$kept_profiles_dir" ]]; then
    log "kept profiles backup at $kept_profiles_dir"
  fi
  if [[ "$removed_xsessions" -gt 0 ]]; then
    log "removed $removed_xsessions RetroFX-managed xsession entries"
  fi
  log "uninstalled RetroFX from $target_home"
}

cmd_status() {
  local mode active_profile="-"

  mode="$(execution_mode)"

  if [[ -f "$ACTIVE_DIR/profile.env" ]]; then
    # shellcheck source=/dev/null
    source "$ACTIVE_DIR/profile.env"
    active_profile="${PROFILE_ID:--}"
  fi

  printf 'RetroFX status\n'
  printf 'Execution mode: %s\n' "$mode"
  printf 'Home dir: %s\n' "$ROOT_DIR"
  printf 'Source dir: %s\n' "$SELF_ROOT_DIR"
  if [[ -n "${RETROFX_HOME:-}" ]]; then
    printf 'RETROFX_HOME: %s\n' "$RETROFX_HOME"
  fi
  if [[ -d "$DEFAULT_INSTALL_HOME" ]]; then
    printf 'Installed home exists: yes (%s)\n' "$DEFAULT_INSTALL_HOME"
  else
    printf 'Installed home exists: no (%s)\n' "$DEFAULT_INSTALL_HOME"
  fi
  if [[ -e "$DEFAULT_LAUNCHER_PATH" ]]; then
    if launcher_is_managed "$DEFAULT_LAUNCHER_PATH"; then
      printf 'Launcher: %s (managed)\n' "$DEFAULT_LAUNCHER_PATH"
    else
      printf 'Launcher: %s (present, unmanaged)\n' "$DEFAULT_LAUNCHER_PATH"
    fi
  else
    printf 'Launcher: not found at %s\n' "$DEFAULT_LAUNCHER_PATH"
  fi
  printf 'Active profile: %s\n' "$active_profile"
}

cmd_version() {
  printf 'retrofx %s | %s\n' "$(read_version)" "$(capability_summary_line)"
}

cmd_self_check() {
  local template
  local session_hint="x11"
  local profile_path
  local ok=1
  local profile_count=0
  local -a missing=()
  local -a parse_errors=()
  local -a required_common=(
    "$ACTIVE_DIR/profile.toml"
    "$ACTIVE_DIR/profile.env"
    "$ACTIVE_DIR/xresources"
    "$ACTIVE_DIR/Xresources"
    "$ACTIVE_DIR/alacritty.toml"
    "$ACTIVE_DIR/semantic.env"
    "$ACTIVE_DIR/tty-palette.env"
    "$ACTIVE_DIR/tty-palette.txt"
    "$ACTIVE_DIR/meta"
  )
  local -a required_templates=(
    "$TEMPLATES_DIR/shader.glsl.in"
    "$TEMPLATES_DIR/picom.conf.in"
    "$TEMPLATES_DIR/xresources.in"
    "$TEMPLATES_DIR/fontconfig.conf.in"
  )
  local f

  ensure_dirs

  for f in "${required_common[@]}"; do
    if [[ ! -f "$f" ]]; then
      missing+=("$f")
      ok=0
    fi
  done

  if [[ -f "$ACTIVE_DIR/meta" ]]; then
    session_hint="$(grep '^session_type=' "$ACTIVE_DIR/meta" | head -n1 | cut -d= -f2 || true)"
    session_hint="${session_hint:-x11}"
  fi

  if [[ -f "$ACTIVE_DIR/profile.toml" ]]; then
    if ! (parse_profile "$ACTIVE_DIR/profile.toml" >/dev/null 2>&1); then
      parse_errors+=("active/profile.toml failed to parse")
      ok=0
    fi
  fi

  if [[ "$session_hint" == "wayland" ]]; then
    if [[ -f "$ACTIVE_DIR/picom.conf" || -f "$ACTIVE_DIR/shader.glsl" ]]; then
      parse_errors+=("wayland active state should not contain picom/shader artifacts")
      ok=0
    fi
  else
    if [[ ! -f "$ACTIVE_DIR/picom.conf" ]]; then
      missing+=("$ACTIVE_DIR/picom.conf")
      ok=0
    fi
    if [[ ! -f "$ACTIVE_DIR/shader.glsl" ]]; then
      missing+=("$ACTIVE_DIR/shader.glsl")
      ok=0
    fi
  fi

  if ! dir_has_files "$LAST_GOOD_DIR"; then
    parse_errors+=("last_good backup is missing or empty")
    ok=0
  fi

  for template in "${required_templates[@]}"; do
    if [[ ! -f "$template" ]]; then
      missing+=("$template")
      ok=0
    fi
  done

  while IFS= read -r profile_path; do
    [[ -f "$profile_path" ]] || continue
    profile_count=$((profile_count + 1))
    if ! (parse_profile "$profile_path" >/dev/null 2>&1); then
      parse_errors+=("profile parse failed: $profile_path")
      ok=0
    fi
  done < <(iter_all_profile_paths)

  if [[ "$profile_count" -eq 0 ]]; then
    parse_errors+=("no profiles found")
    ok=0
  fi

  if [[ "$ok" -eq 1 ]]; then
    log "self-check passed"
    return 0
  fi

  warn "self-check failed"
  if ((${#missing[@]} > 0)); then
    printf 'Missing files:\n' >&2
    for f in "${missing[@]}"; do
      printf '  - %s\n' "$f" >&2
    done
  fi
  if ((${#parse_errors[@]} > 0)); then
    printf 'Validation issues:\n' >&2
    local err
    for err in "${parse_errors[@]}"; do
      printf '  - %s\n' "$err" >&2
    done
  fi
  return 1
}

cmd_repair() {
  local stage_dir=""
  local tmp_profile=""

  ensure_dirs

  if dir_has_files "$LAST_GOOD_DIR"; then
    if restore_last_good; then
      log "repair: restored active state from last_good"
      return 0
    fi
    die "repair failed: unable to restore last_good"
  fi

  warn "repair: last_good missing; generating degraded passthrough fallback"
  tmp_profile="$(mktemp "$STATE_DIR/repair-passthrough.$(now_ts_compact).$$.XXXXXX.toml")"
  create_builtin_passthrough_profile "$tmp_profile"
  load_profile "$tmp_profile"

  stage_dir="$(mktemp -d "$STATE_DIR/repair-stage.$(now_ts_compact).$$.XXXXXX")"
  render_templates "$stage_dir" "$tmp_profile" "wayland"
  validate_stage_outputs "$stage_dir" "wayland" || {
    rm -f "$tmp_profile"
    rm -rf "$stage_dir"
    die "repair failed: generated fallback outputs are invalid"
  }

  backup_active "repair"
  atomic_swap_active "$stage_dir" || {
    rm -f "$tmp_profile"
    rm -rf "$stage_dir"
    die "repair failed: atomic swap failed"
  }

  copy_active_to_last_good || warn "repair: failed to refresh last_good snapshot"
  rm -f "$tmp_profile"
  log "repair: applied degraded passthrough fallback"
}

usage() {
  cat <<'USAGE'
Usage:
  retrofx --version
  retrofx list
  retrofx search <keyword>
  retrofx gallery
  retrofx install-pack <packname>
  retrofx info <profile>
  retrofx apply <profile>
  retrofx import base16 <path-to-json> --name <profile-name>
  retrofx export <alacritty|xresources|base16> <profile> <output_path>
  retrofx self-check
  retrofx repair
  retrofx status
  retrofx install [--yes] [--path <dir>]
  retrofx uninstall [--yes] [--keep-profiles]
  retrofx off [--tty|--all]
  retrofx doctor [--json]
  retrofx preview [profile]
  retrofx new
USAGE
}

main() {
  local cmd="${1:-}"
  local profile_ref="-"
  local needs_runtime_dirs=1

  case "$cmd" in
    --version | version | install | uninstall | status | gallery | "" | -h | --help | help)
      needs_runtime_dirs=0
      ;;
  esac

  if [[ "$needs_runtime_dirs" -eq 1 ]]; then
    ensure_dirs
  fi

  LAST_ERROR=""

  case "$cmd" in
    --version | version)
      shift
      [[ "$#" -eq 0 ]] || die "--version takes no arguments"
      cmd_version
      ;;
    list)
      audit_begin "list" "-"
      shift
      [[ "$#" -eq 0 ]] || die "list takes no arguments"
      cmd_list
      ;;
    search)
      profile_ref="${2:--}"
      audit_begin "search" "$profile_ref"
      shift
      [[ "$#" -eq 1 ]] || die "search requires exactly one keyword"
      cmd_search "$1"
      ;;
    gallery)
      audit_begin "gallery" "-"
      shift
      [[ "$#" -eq 0 ]] || die "gallery takes no arguments"
      cmd_gallery
      ;;
    install-pack)
      profile_ref="${2:--}"
      audit_begin "install-pack" "$profile_ref"
      shift
      [[ "$#" -eq 1 ]] || die "install-pack requires exactly one pack name"
      cmd_install_pack "$1"
      ;;
    info)
      profile_ref="${2:--}"
      audit_begin "info" "$profile_ref"
      shift
      [[ "$#" -eq 1 ]] || die "info requires exactly one profile"
      cmd_info "$1"
      ;;
    import)
      profile_ref="${2:--}"
      audit_begin "import" "$profile_ref"
      shift
      [[ "$#" -ge 1 ]] || die "import requires a format"
      cmd_import "$@"
      ;;
    apply)
      profile_ref="${2:--}"
      audit_begin "apply" "$profile_ref"
      shift
      [[ "$#" -eq 1 ]] || die "apply requires exactly one profile name/path"
      cmd_apply "$1"
      ;;
    export)
      profile_ref="${3:--}"
      audit_begin "export" "$profile_ref"
      shift
      [[ "$#" -eq 3 ]] || die "export requires format, profile, and output_path"
      cmd_export "$1" "$2" "$3"
      ;;
    self-check)
      audit_begin "self-check" "-"
      shift
      [[ "$#" -eq 0 ]] || die "self-check takes no arguments"
      cmd_self_check
      ;;
    repair)
      audit_begin "repair" "-"
      shift
      [[ "$#" -eq 0 ]] || die "repair takes no arguments"
      cmd_repair
      ;;
    status)
      shift
      [[ "$#" -eq 0 ]] || die "status takes no arguments"
      cmd_status
      ;;
    install)
      shift
      cmd_install "$@"
      ;;
    uninstall)
      shift
      cmd_uninstall "$@"
      ;;
    off)
      shift
      if [[ "$#" -gt 1 ]]; then
        die "off takes zero or one option: --tty|--all"
      fi
      case "${1:---profile}" in
        --profile)
          audit_begin "off" "passthrough"
          ;;
        --tty)
          audit_begin "off" "tty"
          ;;
        --all)
          audit_begin "off" "all"
          ;;
        *)
          die "off accepts only --tty or --all"
          ;;
      esac
      cmd_off "${1:---profile}"
      ;;
    doctor)
      audit_begin "doctor" "-"
      shift
      if [[ "$#" -gt 1 ]]; then
        die "doctor takes zero args or --json"
      fi
      if [[ "$#" -eq 1 && "$1" != "--json" ]]; then
        die "doctor only supports --json"
      fi
      cmd_doctor "${1:-text}"
      ;;
    preview)
      profile_ref="${2:--}"
      audit_begin "preview" "$profile_ref"
      shift
      if [[ "$#" -gt 1 ]]; then
        die "preview takes zero or one profile"
      fi
      cmd_preview "$@"
      ;;
    new)
      audit_begin "new" "-"
      shift
      [[ "$#" -eq 0 ]] || die "new takes no arguments"
      cmd_new
      ;;
    "" | -h | --help | help)
      usage
      ;;
    *)
      audit_begin "${cmd:-unknown}" "-"
      die "unknown command '$cmd'"
      ;;
  esac
}

main "$@"
